<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Módulos y Paquetes</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Módulos y Paquetes
]
.subtitle[
## Python I y GitHub
]
.institute[
### Licenciatura en Ciencias Genómicas,UNAM
]
.date[
### 02 May, 2025
]

---





## 🎯 Objetivo de la unidad

&gt; **Comprender cómo reutilizar y organizar código en Python mediante el uso de la instrucción `import`, la creación de módulos y la estructuración de paquetes, promoviendo buenas prácticas de legibilidad, reutilización y escalabilidad.**

---

## 🧠 Introducción

Cuando comenzamos a desarrollar en Python, lo más natural es escribir nuestras propias funciones para resolver un problema. Pero antes de hacer eso, es importante saber que **Python ya viene con una gran cantidad de funciones, módulos y librerías** listas para usarse.

Estas herramientas nos permiten **resolver muchas tareas comunes sin tener que programarlas desde cero**: operaciones matemáticas, manejo de archivos, manipulación de texto, fechas, estadísticas, generación de números aleatorios, entre muchas otras.

&gt; Por eso, una buena práctica es **primero conocer qué funcionalidades ya existen en Python** y cómo podemos usarlas en nuestros programas.

---
## 🧠 Introducción

Las **funciones integradas** (_built-in functions_) son funciones que **ya vienen incluidas en Python**, por lo que puedes usarlas **sin necesidad de importar ninguna librería**.

&gt; Son herramientas básicas que te permiten realizar tareas comunes como contar, convertir tipos, redondear, trabajar con texto, números, listas, etc.


``` python
print("Operaciones")
size = len("ATTTGGTG")
print(round(3.141602,2))
```

PERO ... hay muchas más disponbile.

---
## 🧠 Introducción

La forma de acceder a estas OTRAS herramientas es mediante la instrucción `import`. A lo largo de esta unidad aprenderemos a:

-   Usar `import` para **reutilizar funciones de las librerías de Python**
    
-   Explorar cómo están organizadas estas librerías y módulos
    
-   Y finalmente, aprenderemos a **crear nuestros propios módulos, paquetes y aplicaciones**, tal como lo hace Python

---

### Conceptos Clave

| **Concepto**| **¿Qué es?**                        | **Ejemplo de uso **               |
|------------|--------------------------------------|-------------------------------|
| `import`   | Instrucción que carga otros archivos | `import math`                 |
| Módulo     | Un archivo `.py` con funciones       | `saludos.py`, `utilidades.py` |
| Paquete    | Carpeta con varios módulos `.py`     | `bioinfo/`, `analisis/`       |


&lt;img src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*iL3Hq35sZ3sG26WGpjv8rg.png" width="300px" style="display: block; margin: auto;" /&gt;

.tiny[Source:https://medium.com/pythoneers/6-must-know-words-in-python-ac87ab420ab7]
---

## 🧱 ¿Cómo organiza Python sus librerías?

| Tipo de librería       | Ubicación típica                            | Cómo se usa                        |
|------------------------|---------------------------------------------|------------------------------------|
| 📦 Librería estándar   | Incluida en la instalación de Python        | `import os`, `import math`         |
| 🌐 Librería externa    | Instalada con `pip` en `site-packages/`     | `import pandas as pd`, `import Bio` |
| 📝 Módulo propio       | Archivo `.py` en tu proyecto                | `from utilidades import funcion`   |
| 📁 Paquete propio      | Carpeta con `__init__.py` y varios módulos  | `from bioinfo.analisis import gc`  |

---
## 📁 Estructura típica de librerías en Python

```bash
which python
```

```
python3.X/
├── __pycache__/              ← Código compilado (.pyc)
├── config-3.X/               ← Archivos de configuración del compilador
├── lib-dynload/              ← Módulos compilados como `math.so`, `time.so`
│   ├── math.cpython-310-x86_64-linux-gnu.so
│   └── _datetime.cpython-310-x86_64-linux-gnu.so
├── site-packages/            ← 📦 Librerías externas instaladas con pip
│   ├── numpy/
│   ├── pandas/
│   ├── Bio/                  ← Ej. Biopython
│   ├── __pycache__/
│   └── pip/
├── os.py                     ← Parte de la librería estándar (es Python puro)
├── random.py
├── re.py
├── json/
│   ├── __init__.py
│   └── decoder.py
└── ...                       ← Otros módulos estándar (textwrap, functools, etc.)
```

---

## ¿De dónde importa Python el código?

Python sigue un orden para buscar el código que quieres importar. Este orden está definido en una lista especial llamada `sys.path`.

### Orden de búsqueda:

1.  📁 **Directorio actual** (donde está tu script)
    
2.  🗃️ **Variables de entorno** (como `PYTHONPATH`)
    
3.  🧰 **Librería estándar de Python** (`math`, `os`, `random`, etc.)
    
4.  🌐 **Librerías externas instaladas con `pip`** (en la carpeta `site-packages`)
    
5.  ⚙️ **Carpetas personalizadas** (si las agregas manualmente a `sys.path`)


---

## 📦 La Librería Estándar de Python

### 🧠 ¿Qué es?

La **librería estándar de Python** (Standard Library) es un conjunto de **módulos y paquetes integrados** que vienen incluidos con Python.

&gt; Es como una **“caja de herramientas” lista para usar**: contiene funciones para trabajar con archivos, matemáticas, fechas, expresiones regulares, internet, sistema operativo, y más.

📌 No necesitas instalar nada con `pip`, solo **importarlos**.

---

### 🗂 ¿Cómo está organizada la librería estándar de Python?


| Categoría                 | Módulos típicos                          | Uso principal                         |
|---------------------------|------------------------------------------|---------------------------------------|
| 📐 Matemáticas            | `math`, `statistics`, `cmath`            | Funciones matemáticas y estadísticas  |
| 🧪 Programación funcional | `functools`, `itertools`                 | Funciones de orden superior           |
| 📅 Fechas y tiempos       | `datetime`, `time`, `calendar`           | Manejo de fechas y tiempos            |
| 🗃️ Archivos               | `os`, `shutil`, `pathlib`                | Acceso al sistema de archivos         |
| 🔐 Manejo de errores      | `warnings`, `traceback`                  | Depuración y advertencias             |
| 🔤 Texto y regex          | `re`, `string`, `textwrap`               | Manipulación de texto y patrones      |
| 📡 Internet y red         | `http`, `urllib`, `socket`               | Comunicación en red                   |
| 🧪 Pruebas                | `unittest`, `doctest`                    | Testing de código                     |
| 📄 Entrada/Salida         | `sys`, `argparse`, `fileinput`           | Argumentos y flujos de entrada        |
| 🔁 Concurrencia           | `threading`, `asyncio`, `multiprocessing`| Procesamiento en paralelo y asincronía |


---

## ✅ Ventajas

-   Evitas instalar dependencias externas
    
-   Más rápido de aprender y mantener
    
-   Bien documentado y probado
    
-   Multiplataforma

---

## 📥 `import` y las librerías estándard en Python

### ¿Qué es `import`?

La instrucción `import` en Python permite **usar código que se encuentra en otros archivos**, ya sean módulos de la biblioteca estándar, librerías externas instaladas con `pip`, o archivos `.py` que tú mismo hayas escrito.

&gt; `import` es la herramienta que hace posible **la reutilización del código** en Python.

---
## 🧩 ¿Cómo usar las funciones de la libreria estándar ?

`math`: funciones matemáticas


``` python
import math
print(math.sqrt(49))
```

`os`: operaciones del sistema


``` python
import os
print(os.getcwd())  # Muestra el directorio actual
```


`re`: expresiones regulares

``` python
import re
print(re.findall(r"\d+", "Hoy es 2025-04-29"))  # ['2025', '04', '29']
```


---
## 🔍 ¿Qué hace import cuando se llama a una librería?

1.  **Busca el módulo o librería por nombre**
    
    -   Python revisa las rutas listadas en `sys.path`
        
    -   Busca un archivo o carpeta con ese nombre (`math.py`, `math/__init__.py`, o una extensión compilada como `.so` o `.pyd`)
        
2.  **Carga el módulo**
    
    -   Si lo encuentra, lo **lee y ejecuta su contenido** una sola vez (todo lo que esté fuera de funciones o clases se ejecuta)
        
3.  **Guarda en memoria**
    
    -   El módulo se **carga en caché** (en `sys.modules`) para evitar volver a leerlo si se importa otra vez
        
4.  **Lo vincula al nombre usado**
    
    -   Ahora puedes acceder a su contenido con el nombre que usaste: `math.sqrt()`, `math.pi`, etc.
        

---

### 📥 Formas de usar `import` y `from ... import`

| Sintaxis                           | ¿Qué hace?                                                              | Ejemplo                            |
|------------------------------------|-------------------------------------------------------------------------|------------------------------------|
| `import modulo`                    | Importa todo el módulo. Debes usar el prefijo para acceder a su contenido | `import math` → `math.sqrt(25)`    |
| `import modulo as alias`          | Igual que arriba, pero con un nombre más corto o conveniente            | `import pandas as pd`              |
| `from modulo import objeto`       | Importa solo una parte del módulo (función, clase, variable)            | `from math import pi`              |
| `from modulo import objeto as x`  | Importa un objeto con un alias                                          | `from math import sqrt as raiz`    |
| `from modulo import *` ❌         | Importa todo el contenido al espacio de nombres actual (**desaconsejado**) | `from math import *`               |
| `from paquete.modulo import x`    | Importa desde un módulo dentro de un paquete                           | `from bioinfo.genes import gc`     |

---

### 🧠 ¿Cuál usar y cuándo?

| Necesidad                                 | Recomendación                        |
|-------------------------------------------|--------------------------------------|
| Usar todo el módulo                       | `import modulo`                      |
| Usar solo una función específica          | `from modulo import funcion`         |
| Usar un nombre más corto o común          | `import modulo as alias`             |
| Importar múltiples funciones              | `from modulo import f1, f2, f3`      |
| Evitar conflictos y mantener claridad     | ❌ No usar `from modulo import *`     |
| Modularizar desde tu propio paquete       | `from paquete.modulo import funcion` |



---
## 🧩 Ejemplos

### 1. `import modulo`

Importa todo el módulo. Se accede a sus funciones con el prefijo del módulo.


``` python
import math
print(math.sqrt(16))
```

### 2. `import modulo as alias`

Importa todo el módulo, pero usa un alias más corto.


``` python
import numpy as np
arr = np.array([1, 2, 3])
```

.tiny[ 
Crea un arreglo (array) de NumPy a partir de una lista de Python [1, 2, 3].

Este arreglo arr es similar a una lista, pero con funcionalidades matemáticas más potentes y eficientes (como operaciones vectorizadas, matrices, etc.).
]

---
## 🧩 Ejemplos

### 3. `from modulo import objeto`

Importa solo un elemento (función, clase o variable) del módulo.


``` python
from math import pi
print(pi)
```


###4. `from modulo import objeto as alias`

Importa un elemento específico con un alias:


``` python
from math import log as logaritmo
print(logaritmo(100, 10))
```

---

### 5. `from modulo import *` ❌

Importa todo el contenido del módulo directamente al espacio de nombres actual.


``` python
from math import *
print(sqrt(9))
```

¿Cuál es el problema?? Cuando hay un error o quieres rastrear la función, pierdes su trazabilidad o de donde proviene.

---

## ✅ Buenas prácticas al usar `import` en Python

- 🧼 1. **Coloca todos los `import` al inicio del archivo** permite identificar rápidamente las dependencias.

- 📐 2. **Usa el orden correcto según PEP8**

    Agrupa los `import` en este orden:

    1.  Módulos de la librería estándar
    2.  Librerías de terceros (pip)
    3.  Módulos locales (propios)
    
    Separa cada grupo con una línea en blanco:


``` python
import os
import sys

import pandas as pd

from mi_paquete import herramientas
```

---
## ✅ Buenas prácticas al usar `import` en Python

- 🎯 3. **Importa solo lo necesario** Evita importar todo el módulo si solo usarás una función.

- 🚫 4. **Evita `from modulo import *`** Esto puede sobrescribir variables sin que te des cuenta y hace que el código sea difícil de leer.

- 🧠 5. **Usa alias cuando los nombres sean largos o conflictivos**

- 🗂️67. **Evita importar desde archivos que ejecutan código al ser importados**. Si un archivo no está preparado como módulo, su código puede ejecutarse de forma no deseada.

- 🧪 7. **En proyectos grandes, documenta bien tus dependencias**. Usa `requirements.txt` o `pyproject.toml` para listar qué librerías externas usas. Esto facilita la instalación y mantenimiento.


---



---

## 🧬 Proyecto

**Analizador Genómico** es un programa en Python diseñado para analizar secuencias de ADN almacenadas en archivos FASTA.  
Permite verificar la validez de las secuencias, calcular la frecuencia de bases (A, T, G, C), el contenido GC, y exportar los resultados en un formato tabular (.tsv).


### Actividad

- Descarga el archivo .zip de la plataforma
- mueve el archivo a tu carpeta de proyectos y descomprimelo
- Lee el README y detalles del proyecto
- Checa los datos de entrada
- Analiza el programa de python

---
## 🧩 ¿Qué aprenderemos a continuación?

A organizar mejor nuestro código: separar funciones, reutilizarlas, construir módulos y paquetes…
tal como lo hacen los proyectos profesionales de Python.

###  Qué haremos?

- Dividir el programa en módulos temáticos (fasta_utils.py, bio_stats.py, etc.)

- Crear un paquete completo y reutilizable

- Usar import para ensamblar las partes del sistema
    
---

## 🧠 Introducción a los Módulos en Python

Cuando los programas crecen, tener **todo el código en un solo archivo** los vuelve:

-   Difíciles de mantener
    
-   Complicados de reutilizar
    
-   Poco legibles para otros
    

&gt; 🧩 Un **módulo** es simplemente un archivo `.py` que contiene funciones, clases o variables que puedes **importar desde otros archivos** para organizarlos mejor.

---

### ✅ Ventajas de usar módulos

-   Organiza el código por tema o funcionalidad
    
-   Reutiliza código sin copiar y pegar
    
-   Facilita el trabajo en equipo y el mantenimiento
    
-   Da el primer paso para construir **paquetes**
    

---

## 🛠️ ¿Qué se necesita para crear un módulo?

1.  ✅ Un archivo `.py` que contiene funciones, variables o clases.
    
2.  ✅ Un nombre claro y sin espacios (`fasta_utils.py`, `bio_stats.py`, etc.)
    
3.  ✅ Un uso explícito de `import` para acceder desde otros scripts.
    
4.  📄 Documentación breve en forma de docstrings.
    
5.  ❌ No tener código ejecutable suelto (idealmente sin `print()`s fuera de funciones).
    

---


``` python
# nombre_modulo.py

"""
Docstring del módulo: explica qué contiene y para qué sirve.
"""

# 1. Importaciones necesarias
import os
from pathlib import Path

# 2. Constantes (si aplica)
BASES_VALIDAS = {"A", "T", "G", "C"}

# 3. Funciones o clases
def mi_funcion(x):
    """Descripción de la función"""
    return x * 2

# 4. (Opcional) Código de prueba o demostración
if __name__ == "__main__":
    print(mi_funcion(5))
```

---
### 📦 ¿Cómo se usa?

Supongamos que tienes un archivo llamado `fasta_utils.py` con esta función:



``` python
# fasta_utils.py
def leer_fasta(path):
    ...
```

En otro archivo, puedes usarla así:



``` python
from fasta_utils import leer_fasta

secuencias = leer_fasta("data/secuencias.fasta")
```

---
## 🧩 Análisis del programa actual

### 🔍 ¿Qué hace el programa?

--

-   **Entrada**: Lee un archivo FASTA con secuencias de ADN
    
-   **Validación**: Verifica que solo tenga bases A, T, G, C
    
-   **Procesamiento**:
    
    -   Cuenta bases
        
    -   Calcula contenido GC
        
-   **Salida**: Exporta un archivo `.tsv`
    
-   **Pruebas**: Contiene pruebas con `assert`

---

### 📦 Propuesta de división en módulos del proyecto

| Módulo               | Funciones incluidas                             | Propósito                                                             |
|----------------------|--------------------------------------------------|----------------------------------------------------------------------|
| `fasta_utils.py`   | `leer_fasta()`                                   | Leer y cargar secuencias desde archivos en formato FASTA            |
| `validador.py`       | `validar_secuencia()`                            | Validar que las secuencias contengan solo bases A, T, G y C          |
| `bioestadisticas.py` | `contar_bases()`, `calcular_gc()`                | Calcular frecuencias de bases y contenido GC                         |
| `exportador.py`      | `exportar_tsv()`                                 | Exportar resultados del análisis a archivo `.tsv`                    |
| `analizador.py`      | Uso de los módulos anteriores para ejecutar todo | Coordinar lectura, validación, análisis y exportación               |
| `test_analizador.py` | Pruebas con `assert` o `unittest`                | Verificar que las funciones de cada módulo se comporten correctamente  |

---
## Actividad

&gt; Separa las funciones y Generar todos los módulos.

```
analizador_genomico/              ← Carpeta raíz del proyecto
├── data/                         ← Entrada: archivos FASTA
│   └── secuencias.fasta
│
├── salida/                       ← Salida: archivos de resultados
│   └── resultados.tsv
│
├── fasta_utils.py               ← Módulo: lectura y manejo de archivos FASTA
├── validador.py                 ← Módulo: validación de secuencias
├── bioestadisticas.py           ← Módulo: conteo de bases y cálculo GC
├── exportador.py                ← Módulo: exportación a archivo
├── analizador.py                ← Script principal (orquestador del flujo)
│
├── test_analizador.py           ← Pruebas con assert o unittest
│
├── README.md                    ← Descripción general del proyecto
└── detalles_proyecto.md         ← Objetivo, estructura y formatos
```

--

&gt; Si. no logras terminarlo descarga `analizador_genomico_modulos.zip`. (puedes renombrar tu carpeta actual y copiar la nueva. O puedes borrar el actual proyecto y copiar la nueva)

---
## ▶️ 1. Ejecutar desde la terminal

Estando en la carpeta `analizador_genomico/`, simplemente:


``` python
python analizador.py
```

Este comando:

-   Importará funciones de los módulos `.py` vecinos
    
-   Leerá `data/secuencias.fasta`
    
-   Guardará `salida/resultados.tsv`

---
## Añadiendo funcionalidades

Quieres un script `guardar_secuencias.py` que formatee de fasta a tsv. Entonces :

-   Lee el archivo `data/secuencias.fasta`
-   Genera un archivo `salida/secuencias.tsv` con dos columnas: `ID` y `Secuencia`

&gt; Descarga y mueve a tu proyecto `guardar_secuencias.py`
&gt; Ejecutalo

---
## ⚠️ Nota importante

Si ejecutas el script desde otro directorio (por ejemplo, usando VSCode o desde una notebook en otra carpeta), Python no encontrará los módulos.

Soluciones:

- Ejecutar siempre desde la raíz del proyecto

- Añadir el path manualmente a sys.path

- O mejor aún, convertir el proyecto en paquete.

---
## 🧠 ¿Qué es `sys.path`?

Es una **lista de rutas** que Python examina cuando haces un `import`. Si el módulo no está en ninguna de esas rutas, verás un error `ModuleNotFoundError: No module named 'fasta_utils'`


** ✅ ¿Cómo añadir una ruta a `sys.path`? **

Supón que estás en otro directorio y quieres importar desde `analizador_genomico/`:


``` python
import sys
sys.path.append("ruta/a/analizador_genomico")
from fasta_utils import leer_fasta
```

---
## 🛑 Recomendación

- 👉 Solo usa `sys.path.append()` en scripts o notebooks de desarrollo temporal. 

- Para proyectos formales o producción, **mejor estructura el código como paquete**.

---

### ⚠️ ¿Por qué `analizador.py` necesita tratarse de forma distinta?

Todos los módulos que hemos creado (`fasta_utils.py`, `validador.py`, etc.) **contienen exclusivamente funciones**.  

Sin embargo, `analizador.py` es diferente: **contiene el flujo principal del programa**, es decir, **es el script que ejecuta** todo el análisis llamando a los demás módulos.

&gt; 🛑 A simple vista, todos los archivos `.py` parecen ser "módulos" reutilizables.  
Esto puede llevar a que **otro programador, sin conocer los detalles, intente importar `analizador.py` como si fuera un módulo más**. ¿Qué pasaría?

---
## ejemplo

1. Tienes un modulo llamado `saludo.py`


``` python
def hola():
    print("Hola")
```

2. y tienes un programa que usa ese módulo


``` python
from saludo import hola

nombre = "Aby"
```

3. Qué pasa si al módulo `saludo.py` le agregamos una línea fuera de la función


``` python
print("mundo")
```

---

### ❌ ¿Qué sucede si `analizador.py` tiene código suelto (fuera de funciones)?

Si el archivo contiene instrucciones directamente ejecutables (por ejemplo, lectura de archivos, impresión, procesamiento), estas **se ejecutarán automáticamente al hacer el import**, incluso si solo se quería acceder a una función.

Esto puede provocar:

-   ❗ Procesos inesperados (lectura de archivos, ejecución completa)
    
-   ❗ Resultados incorrectos o repetidos
    
-   ❗ Dificultades para probar, extender o reutilizar el código

---
## ✅ ¿Cómo evitamos esto?

La solución es **encapsular el flujo del análisis dentro de una función `main()`** y protegerlo con:


``` python
if __name__ == "__main__":
    main()
```


---
## 🧠 ¿Qué significa `__name__` ?

- `__name__` es una **variable especial incorporada** (built-in) en cada archivo `.py` que se ejecuta o importa.  

- Su valor **depende del contexto** en el que se está ejecutando el archivo.


#### 🧪 Técnicamente: ¿Qué valor tiene `__name__`?

| Contexto de ejecución                  | Valor de `__name__`  |
|----------------------------------------|-----------------------|
| Ejecutas el archivo directamente       | `"__main__"`         |
| Importas el archivo desde otro script  | Nombre del archivo (sin `.py`) |


---
## Ejemplo

1.  Agrega la siguiente linea de código al final del programa `analizador.py`


``` python
print(f"__name__ vale: {__name__}")
```

Desde la linea de comando, corre el programa analizador y tiene que imprimir 


``` bash
% python analizador.py 

[OK] Resultados guardados en: output/resultados.tsv
__name__ vale: __main__
```

---
## Ejemplo

Ahora, creemo un script que se llame `llama_analizador.py` que tenga las siguientes líneas de código:



``` python
import analizador  # estamos importanto analizador como módulo

x = 10
```

Y ejecuta en `llama_analizador.py` , te debe regresar esto:



``` python
% python llama_analizador.py

[OK] Resultados guardados en: output/resultados.tsv
__name__ vale: analizador
```

**¿Cuál es el valor de __name__?**

---
## 🎯 ¿Para qué sirve?

Permite diferenciar entre:

-   👨‍💻 **Ejecutar un archivo como programa principal**
    
-   🧩 **Importarlo como módulo en otro script**
    

Por eso usamos esta estructura:


``` python
if __name__ == "__main__":
    main()
```

Así controlamos **cuándo** debe ejecutarse el flujo principal del programa.

---
## Ejercicio

1. Actualiza el programa `analizador.py` Usando esta estructura estándar:


``` python
def main():
    # Código del análisis (leer, validar, calcular, exportar)

if __name__ == "__main__":
    main()
```

2. Vuelve a correr 

```bash
% python analizador.py 
% python llama_analizador.py
```

--

&gt; Si no has terminado copia el archivo `analizador2.py`

---

## 🧩 Módulo --&gt; Paquete ??

** ✅ Señales claras de que es buen momento para convertir tu proyecto en paquete **

| Situación                                           | ¿Conviene empaquetar? |
|----------------------------------------------------|------------------------|
| Ya tienes módulos reutilizables (`*.py`)           | ✔️ Sí                   |
| Planeas usar el código en varios proyectos         | ✔️ Sí                   |
| Lo vas a compartir públicamente o en equipo        | ✔️ Sí                   |
| Solo es un script puntual con lógica específica    | ❌ No                  |

--

#### Qué hacer?

- Convertirlo en un paquete con subcarpetas (`__init__.py`)
- Mover los módulos a la carpeta `src/paquete/` (p.e. `src/analizador/`)
- Usar `setup.py` o `pyproject.toml` para instalación
- Añadir `notebooks/` para visualización o pruebas interactivas
    
---
## 🧱 Estructura final de un paquete básico

```
analizador_genomico/             ← Carpeta raíz del proyecto
├── src/                         ← Código fuente del paquete
│   └── analizador/              ← Nombre del paquete (import analizador)
│       ├── __init__.py
│       ├── fasta_utils.py
│       ├── validador.py
│       ├── bioestadisticas.py
│       └── exportador.py
│
├── analizador.py                ← Script ejecutable
├── guardar_secuencias.py        ← Script ejecutable
├── tests/                       ← Carpeta para pruebas
│   └── test_analizador.py
│
├── data/                        ← Entrada: FASTA
├── output/                      ← Salida: resultados
│
├── README.md
├── detalles_proyecto.md
├── pyproject.toml               ← ⚙️ Configuración moderna del paquete
└── setup.cfg                    ← (opcional) Configuración extendida
```

---
## 🧠 ¿Qué es `__init__.py`?

Es un **archivo especial** que se coloca dentro de un directorio para decirle a Python:

&gt; “💡 Esta carpeta debe tratarse como un paquete Python.”

--

| Propósito                                | Descripción                                                                 |
|------------------------------------------|-----------------------------------------------------------------------------|
| 🧭 Habilita el paquete                   | Python reconocerá la carpeta como un paquete válido                        |
| 📂 Permite importar módulos internos     | Puedes hacer `from mi_paquete import modulo`                               |
| 🧱 Define qué se exporta por defecto     | Puedes controlar qué se importa con `from paquete import *` usando `__all__` |
| 🧪 Código de inicialización (opcional)   | Puedes ejecutar código cuando el paquete se importa por primera vez        |

---

## ✏️ Contenido típico

-   Puede estar vacío (`pass`)
    
-   O tener un docstring:

```
"""Este paquete contiene herramientas para analizar secuencias genómicas."""
```

-   O inicializar cosas si se requiere

---
## 📄 `pyproject.toml`

Es el **archivo principal de configuración de un proyecto Python moderno**.  
Define cómo se debe construir, instalar y empaquetar tu proyecto.

### 🧠 ¿Para qué sirve?

-   Especifica:
    
    -   Nombre del proyecto
    -   Versión
    -   Autor(es)
    -   Requisitos de Python
    -   Dependencias (`dependencies = []`)
        
-   Define el sistema de construcción (`setuptools`, `flit`, `poetry`, etc.). 🔧 setuptools es el motor que construye, empaqueta e instala tu proyecto
    
-   Es el **reemplazo moderno de `setup.py`**

---
## 📄 `setup.cfg`

Es un archivo opcional para **definir metadatos y configuraciones adicionales**.  
Se usa junto con `pyproject.toml` para separar la configuración del código Python.

### 🧠 ¿Para qué sirve?

-   Describe el paquete
    
-   Declara los paquetes y módulos a incluir
    
-   Define la versión mínima de Python
    
-   Permite usar `setuptools` sin código en `setup.py`

---
## Qué pasa si ejecuto `analizador.py`

**¿Puedo ejecutar el paquete sin instalarlo?** Si corres `analizador.py` no encontrará los paquetes.

¿Qué hacer? necesitas agregar la carpeta src/ al sys.path.


``` python
# analizador.py (ubicado en la raíz del proyecto)

import sys
from pathlib import Path

# Agrega la carpeta src al path
sys.path.append(str(Path(__file__).resolve().parent / "src"))

# Ahora puedes importar tu paquete
from analizador.fasta_utils import leer_fasta
```

---
## 🧩 ¿Qué hace?


``` python
# Agrega la carpeta src al path
sys.path.append(str(Path(__file__).resolve().parent / "src"))
```


- **`Path(__file__)`**	: Obtiene la ruta del archivo actual (`analizador.py`) como objeto `Path`
- **`.resolve()`**	: Convierte esa ruta en una **ruta absoluta** (resuelve `..`, `.`)
- **`.parent`**	: Obtiene el directorio que **contiene** ese archivo (el directorio raíz del proyecto)
- **`Path(...) / "src"`**	: Une la ruta del directorio raíz con `"src"` → construye la ruta completa a `src/`
- **`str(...)`** : Convierte ese `Path` en una cadena de texto, que es lo que `sys.path.append()` espera
- **`sys.path.append(...)`**	: Agrega esa ruta a la lista de búsqueda de módulos de Python (`sys.path`)


Corre `analizador.py` **funciona**?

---

## 🛠️ El problema

Tienes un archivo llamado `analizador.py` en la raíz, y también una carpeta llamada `analizador` dentro de `src/`.  

Python ve primero el archivo `analizador.py` y **lo confunde con un paquete**, lo cual **rompe la importación**.

&gt; 🔄 Cambia el nombre del archivo `analizador.py` a, por ejemplo, `main.py` o `run.py`. Esto evitará el conflicto de nombres, y **la importación desde `src/analizador/` funcionará perfectamente**.


**¿Funcionó??**

---
## ¿Cómo instalar tu paquete local en modo editable con pip?

#### 1. Asegúrate de tener esta estructura mínima,  vista anteriormente.
#### 2. Abre una terminal y cambia al directorio raíz del proyecto
#### 3. Instala el paquete en modo *editable*

```bash
pip install -e .
```

Esto permite que cualquier cambio que hagas en `src/analizador/` se refleje sin necesidad de reinstalar.

---

### 🧪 4. Verifica que todo está bien

Desde cualquier parte, abre Python y ejecuta:


``` python
from analizador.fasta_utils import leer_fasta

seqf = "seq.dna"
secuencias = leer_fasta(seqf)

print(secuencias)
```

✅ Si no hay errores, ¡tu paquete está funcionando!

### 🧼 5. Recomendación

Una vez instalado el paquete con `pip install -e .`, puedes eliminar cualquier línea como:


``` python
sys.path.append(...)
```


---
## ✅ Conclusiones principales

-   `import` permite **reutilizar código** desde otros archivos o librerías.
    
-   Un **módulo** es un archivo `.py` con funciones que puedes importar.
    
-   Un **paquete** es una carpeta con módulos y un `__init__.py`.
    
-   Usa `main()` y `if __name__ == "__main__"` para **controlar cuándo se ejecuta el programa**.
    
-   `__name__` es `"__main__"` solo si el archivo se ejecuta directamente.
    
-   `__init__.py` activa el paquete y puede definirse configuraciones iniciales.
    
-   `setuptools` se usa para **construir e instalar** tu paquete.
    
-   Con `pip install -e .` puedes usar tu código como paquete sin moverlo.
    
-   El uso correcto de módulos y paquetes hace tu código **más limpio, reutilizable y profesional**.


---

## 🚀 Funcionalidades avanzadas con paquetes

-   ✅ **Distribución e instalación** con `pip` (`.whl`, `.tar.gz`)
-   🧪 **Pruebas automatizadas** con `unittest`, `pytest`, `tox`
-   🧩 **Definición de comandos ejecutables** (`console_scripts`)
-   🧱 **Subpaquetes y namespaces** (`paquete.subpaquete.modulo`)
-   🔐 **Control de visibilidad** con `__all__` y `__init__.py`
-   📦 **Publicación en PyPI** para compartir con la comunidad
-   🧬 **Compatibilidad con entornos virtuales** y `venv`
-   📁 **Inclusión de archivos no Python** (datos, plantillas, scripts)
-   🔁 **Integración continua (CI)** con GitHub Actions, GitLab CI, etc.
-   📑 **Documentación automática** con `Sphinx` o `MkDocs`
-   🗂️ **Organización multi-paquete** en proyectos grandes (monorepo)
-   🔄 **Interoperabilidad con C/C++** usando extensiones compiladas (`.so`, `.pyd`)
-   🧰 **Soporte para plugins** mediante `entry_points`
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
