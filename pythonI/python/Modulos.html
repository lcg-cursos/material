<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>MÃ³dulos y Paquetes</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# MÃ³dulos y Paquetes
]
.subtitle[
## Python I y GitHub
]
.institute[
### Licenciatura en Ciencias GenÃ³micas,UNAM
]
.date[
### 02 May, 2025
]

---





## ğŸ¯ Objetivo de la unidad

&gt; **Comprender cÃ³mo reutilizar y organizar cÃ³digo en Python mediante el uso de la instrucciÃ³n `import`, la creaciÃ³n de mÃ³dulos y la estructuraciÃ³n de paquetes, promoviendo buenas prÃ¡cticas de legibilidad, reutilizaciÃ³n y escalabilidad.**

---

## ğŸ§  IntroducciÃ³n

Cuando comenzamos a desarrollar en Python, lo mÃ¡s natural es escribir nuestras propias funciones para resolver un problema. Pero antes de hacer eso, es importante saber que **Python ya viene con una gran cantidad de funciones, mÃ³dulos y librerÃ­as** listas para usarse.

Estas herramientas nos permiten **resolver muchas tareas comunes sin tener que programarlas desde cero**: operaciones matemÃ¡ticas, manejo de archivos, manipulaciÃ³n de texto, fechas, estadÃ­sticas, generaciÃ³n de nÃºmeros aleatorios, entre muchas otras.

&gt; Por eso, una buena prÃ¡ctica es **primero conocer quÃ© funcionalidades ya existen en Python** y cÃ³mo podemos usarlas en nuestros programas.

---
## ğŸ§  IntroducciÃ³n

Las **funciones integradas** (_built-in functions_) son funciones que **ya vienen incluidas en Python**, por lo que puedes usarlas **sin necesidad de importar ninguna librerÃ­a**.

&gt; Son herramientas bÃ¡sicas que te permiten realizar tareas comunes como contar, convertir tipos, redondear, trabajar con texto, nÃºmeros, listas, etc.


``` python
print("Operaciones")
size = len("ATTTGGTG")
print(round(3.141602,2))
```

PERO ... hay muchas mÃ¡s disponbile.

---
## ğŸ§  IntroducciÃ³n

La forma de acceder a estas OTRAS herramientas es mediante la instrucciÃ³n `import`. A lo largo de esta unidad aprenderemos a:

-   Usar `import` para **reutilizar funciones de las librerÃ­as de Python**
    
-   Explorar cÃ³mo estÃ¡n organizadas estas librerÃ­as y mÃ³dulos
    
-   Y finalmente, aprenderemos a **crear nuestros propios mÃ³dulos, paquetes y aplicaciones**, tal como lo hace Python

---

### Conceptos Clave

| **Concepto**| **Â¿QuÃ© es?**                        | **Ejemplo de uso **               |
|------------|--------------------------------------|-------------------------------|
| `import`   | InstrucciÃ³n que carga otros archivos | `import math`                 |
| MÃ³dulo     | Un archivo `.py` con funciones       | `saludos.py`, `utilidades.py` |
| Paquete    | Carpeta con varios mÃ³dulos `.py`     | `bioinfo/`, `analisis/`       |


&lt;img src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*iL3Hq35sZ3sG26WGpjv8rg.png" width="300px" style="display: block; margin: auto;" /&gt;

.tiny[Source:https://medium.com/pythoneers/6-must-know-words-in-python-ac87ab420ab7]
---

## ğŸ§± Â¿CÃ³mo organiza Python sus librerÃ­as?

| Tipo de librerÃ­a       | UbicaciÃ³n tÃ­pica                            | CÃ³mo se usa                        |
|------------------------|---------------------------------------------|------------------------------------|
| ğŸ“¦ LibrerÃ­a estÃ¡ndar   | Incluida en la instalaciÃ³n de Python        | `import os`, `import math`         |
| ğŸŒ LibrerÃ­a externa    | Instalada con `pip` en `site-packages/`     | `import pandas as pd`, `import Bio` |
| ğŸ“ MÃ³dulo propio       | Archivo `.py` en tu proyecto                | `from utilidades import funcion`   |
| ğŸ“ Paquete propio      | Carpeta con `__init__.py` y varios mÃ³dulos  | `from bioinfo.analisis import gc`  |

---
## ğŸ“ Estructura tÃ­pica de librerÃ­as en Python

```bash
which python
```

```
python3.X/
â”œâ”€â”€ __pycache__/              â† CÃ³digo compilado (.pyc)
â”œâ”€â”€ config-3.X/               â† Archivos de configuraciÃ³n del compilador
â”œâ”€â”€ lib-dynload/              â† MÃ³dulos compilados como `math.so`, `time.so`
â”‚   â”œâ”€â”€ math.cpython-310-x86_64-linux-gnu.so
â”‚   â””â”€â”€ _datetime.cpython-310-x86_64-linux-gnu.so
â”œâ”€â”€ site-packages/            â† ğŸ“¦ LibrerÃ­as externas instaladas con pip
â”‚   â”œâ”€â”€ numpy/
â”‚   â”œâ”€â”€ pandas/
â”‚   â”œâ”€â”€ Bio/                  â† Ej. Biopython
â”‚   â”œâ”€â”€ __pycache__/
â”‚   â””â”€â”€ pip/
â”œâ”€â”€ os.py                     â† Parte de la librerÃ­a estÃ¡ndar (es Python puro)
â”œâ”€â”€ random.py
â”œâ”€â”€ re.py
â”œâ”€â”€ json/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ decoder.py
â””â”€â”€ ...                       â† Otros mÃ³dulos estÃ¡ndar (textwrap, functools, etc.)
```

---

## Â¿De dÃ³nde importa Python el cÃ³digo?

Python sigue un orden para buscar el cÃ³digo que quieres importar. Este orden estÃ¡ definido en una lista especial llamada `sys.path`.

### Orden de bÃºsqueda:

1.  ğŸ“ **Directorio actual** (donde estÃ¡ tu script)
    
2.  ğŸ—ƒï¸ **Variables de entorno** (como `PYTHONPATH`)
    
3.  ğŸ§° **LibrerÃ­a estÃ¡ndar de Python** (`math`, `os`, `random`, etc.)
    
4.  ğŸŒ **LibrerÃ­as externas instaladas con `pip`** (en la carpeta `site-packages`)
    
5.  âš™ï¸ **Carpetas personalizadas** (si las agregas manualmente a `sys.path`)


---

## ğŸ“¦ La LibrerÃ­a EstÃ¡ndar de Python

### ğŸ§  Â¿QuÃ© es?

La **librerÃ­a estÃ¡ndar de Python** (Standard Library) es un conjunto de **mÃ³dulos y paquetes integrados** que vienen incluidos con Python.

&gt; Es como una **â€œcaja de herramientasâ€ lista para usar**: contiene funciones para trabajar con archivos, matemÃ¡ticas, fechas, expresiones regulares, internet, sistema operativo, y mÃ¡s.

ğŸ“Œ No necesitas instalar nada con `pip`, solo **importarlos**.

---

### ğŸ—‚ Â¿CÃ³mo estÃ¡ organizada la librerÃ­a estÃ¡ndar de Python?


| CategorÃ­a                 | MÃ³dulos tÃ­picos                          | Uso principal                         |
|---------------------------|------------------------------------------|---------------------------------------|
| ğŸ“ MatemÃ¡ticas            | `math`, `statistics`, `cmath`            | Funciones matemÃ¡ticas y estadÃ­sticas  |
| ğŸ§ª ProgramaciÃ³n funcional | `functools`, `itertools`                 | Funciones de orden superior           |
| ğŸ“… Fechas y tiempos       | `datetime`, `time`, `calendar`           | Manejo de fechas y tiempos            |
| ğŸ—ƒï¸ Archivos               | `os`, `shutil`, `pathlib`                | Acceso al sistema de archivos         |
| ğŸ” Manejo de errores      | `warnings`, `traceback`                  | DepuraciÃ³n y advertencias             |
| ğŸ”¤ Texto y regex          | `re`, `string`, `textwrap`               | ManipulaciÃ³n de texto y patrones      |
| ğŸ“¡ Internet y red         | `http`, `urllib`, `socket`               | ComunicaciÃ³n en red                   |
| ğŸ§ª Pruebas                | `unittest`, `doctest`                    | Testing de cÃ³digo                     |
| ğŸ“„ Entrada/Salida         | `sys`, `argparse`, `fileinput`           | Argumentos y flujos de entrada        |
| ğŸ” Concurrencia           | `threading`, `asyncio`, `multiprocessing`| Procesamiento en paralelo y asincronÃ­a |


---

## âœ… Ventajas

-   Evitas instalar dependencias externas
    
-   MÃ¡s rÃ¡pido de aprender y mantener
    
-   Bien documentado y probado
    
-   Multiplataforma

---

## ğŸ“¥ `import` y las librerÃ­as estÃ¡ndard en Python

### Â¿QuÃ© es `import`?

La instrucciÃ³n `import` en Python permite **usar cÃ³digo que se encuentra en otros archivos**, ya sean mÃ³dulos de la biblioteca estÃ¡ndar, librerÃ­as externas instaladas con `pip`, o archivos `.py` que tÃº mismo hayas escrito.

&gt; `import` es la herramienta que hace posible **la reutilizaciÃ³n del cÃ³digo** en Python.

---
## ğŸ§© Â¿CÃ³mo usar las funciones de la libreria estÃ¡ndar ?

`math`: funciones matemÃ¡ticas


``` python
import math
print(math.sqrt(49))
```

`os`: operaciones del sistema


``` python
import os
print(os.getcwd())  # Muestra el directorio actual
```


`re`: expresiones regulares

``` python
import re
print(re.findall(r"\d+", "Hoy es 2025-04-29"))  # ['2025', '04', '29']
```


---
## ğŸ” Â¿QuÃ© hace import cuando se llama a una librerÃ­a?

1.  **Busca el mÃ³dulo o librerÃ­a por nombre**
    
    -   Python revisa las rutas listadas en `sys.path`
        
    -   Busca un archivo o carpeta con ese nombre (`math.py`, `math/__init__.py`, o una extensiÃ³n compilada como `.so` o `.pyd`)
        
2.  **Carga el mÃ³dulo**
    
    -   Si lo encuentra, lo **lee y ejecuta su contenido** una sola vez (todo lo que estÃ© fuera de funciones o clases se ejecuta)
        
3.  **Guarda en memoria**
    
    -   El mÃ³dulo se **carga en cachÃ©** (en `sys.modules`) para evitar volver a leerlo si se importa otra vez
        
4.  **Lo vincula al nombre usado**
    
    -   Ahora puedes acceder a su contenido con el nombre que usaste: `math.sqrt()`, `math.pi`, etc.
        

---

### ğŸ“¥ Formas de usar `import` y `from ... import`

| Sintaxis                           | Â¿QuÃ© hace?                                                              | Ejemplo                            |
|------------------------------------|-------------------------------------------------------------------------|------------------------------------|
| `import modulo`                    | Importa todo el mÃ³dulo. Debes usar el prefijo para acceder a su contenido | `import math` â†’ `math.sqrt(25)`    |
| `import modulo as alias`          | Igual que arriba, pero con un nombre mÃ¡s corto o conveniente            | `import pandas as pd`              |
| `from modulo import objeto`       | Importa solo una parte del mÃ³dulo (funciÃ³n, clase, variable)            | `from math import pi`              |
| `from modulo import objeto as x`  | Importa un objeto con un alias                                          | `from math import sqrt as raiz`    |
| `from modulo import *` âŒ         | Importa todo el contenido al espacio de nombres actual (**desaconsejado**) | `from math import *`               |
| `from paquete.modulo import x`    | Importa desde un mÃ³dulo dentro de un paquete                           | `from bioinfo.genes import gc`     |

---

### ğŸ§  Â¿CuÃ¡l usar y cuÃ¡ndo?

| Necesidad                                 | RecomendaciÃ³n                        |
|-------------------------------------------|--------------------------------------|
| Usar todo el mÃ³dulo                       | `import modulo`                      |
| Usar solo una funciÃ³n especÃ­fica          | `from modulo import funcion`         |
| Usar un nombre mÃ¡s corto o comÃºn          | `import modulo as alias`             |
| Importar mÃºltiples funciones              | `from modulo import f1, f2, f3`      |
| Evitar conflictos y mantener claridad     | âŒ No usar `from modulo import *`     |
| Modularizar desde tu propio paquete       | `from paquete.modulo import funcion` |



---
## ğŸ§© Ejemplos

### 1. `import modulo`

Importa todo el mÃ³dulo. Se accede a sus funciones con el prefijo del mÃ³dulo.


``` python
import math
print(math.sqrt(16))
```

### 2. `import modulo as alias`

Importa todo el mÃ³dulo, pero usa un alias mÃ¡s corto.


``` python
import numpy as np
arr = np.array([1, 2, 3])
```

.tiny[ 
Crea un arreglo (array) de NumPy a partir de una lista de Python [1, 2, 3].

Este arreglo arr es similar a una lista, pero con funcionalidades matemÃ¡ticas mÃ¡s potentes y eficientes (como operaciones vectorizadas, matrices, etc.).
]

---
## ğŸ§© Ejemplos

### 3. `from modulo import objeto`

Importa solo un elemento (funciÃ³n, clase o variable) del mÃ³dulo.


``` python
from math import pi
print(pi)
```


###4. `from modulo import objeto as alias`

Importa un elemento especÃ­fico con un alias:


``` python
from math import log as logaritmo
print(logaritmo(100, 10))
```

---

### 5. `from modulo import *` âŒ

Importa todo el contenido del mÃ³dulo directamente al espacio de nombres actual.


``` python
from math import *
print(sqrt(9))
```

Â¿CuÃ¡l es el problema?? Cuando hay un error o quieres rastrear la funciÃ³n, pierdes su trazabilidad o de donde proviene.

---

## âœ… Buenas prÃ¡cticas al usar `import` en Python

- ğŸ§¼ 1. **Coloca todos los `import` al inicio del archivo** permite identificar rÃ¡pidamente las dependencias.

- ğŸ“ 2. **Usa el orden correcto segÃºn PEP8**

    Agrupa los `import` en este orden:

    1.  MÃ³dulos de la librerÃ­a estÃ¡ndar
    2.  LibrerÃ­as de terceros (pip)
    3.  MÃ³dulos locales (propios)
    
    Separa cada grupo con una lÃ­nea en blanco:


``` python
import os
import sys

import pandas as pd

from mi_paquete import herramientas
```

---
## âœ… Buenas prÃ¡cticas al usar `import` en Python

- ğŸ¯ 3. **Importa solo lo necesario** Evita importar todo el mÃ³dulo si solo usarÃ¡s una funciÃ³n.

- ğŸš« 4. **Evita `from modulo import *`** Esto puede sobrescribir variables sin que te des cuenta y hace que el cÃ³digo sea difÃ­cil de leer.

- ğŸ§  5. **Usa alias cuando los nombres sean largos o conflictivos**

- ğŸ—‚ï¸67. **Evita importar desde archivos que ejecutan cÃ³digo al ser importados**. Si un archivo no estÃ¡ preparado como mÃ³dulo, su cÃ³digo puede ejecutarse de forma no deseada.

- ğŸ§ª 7. **En proyectos grandes, documenta bien tus dependencias**. Usa `requirements.txt` o `pyproject.toml` para listar quÃ© librerÃ­as externas usas. Esto facilita la instalaciÃ³n y mantenimiento.


---



---

## ğŸ§¬ Proyecto

**Analizador GenÃ³mico** es un programa en Python diseÃ±ado para analizar secuencias de ADN almacenadas en archivos FASTA.  
Permite verificar la validez de las secuencias, calcular la frecuencia de bases (A, T, G, C), el contenido GC, y exportar los resultados en un formato tabular (.tsv).


### Actividad

- Descarga el archivo .zip de la plataforma
- mueve el archivo a tu carpeta de proyectos y descomprimelo
- Lee el README y detalles del proyecto
- Checa los datos de entrada
- Analiza el programa de python

---
## ğŸ§© Â¿QuÃ© aprenderemos a continuaciÃ³n?

A organizar mejor nuestro cÃ³digo: separar funciones, reutilizarlas, construir mÃ³dulos y paquetesâ€¦
tal como lo hacen los proyectos profesionales de Python.

###  QuÃ© haremos?

- Dividir el programa en mÃ³dulos temÃ¡ticos (fasta_utils.py, bio_stats.py, etc.)

- Crear un paquete completo y reutilizable

- Usar import para ensamblar las partes del sistema
    
---

## ğŸ§  IntroducciÃ³n a los MÃ³dulos en Python

Cuando los programas crecen, tener **todo el cÃ³digo en un solo archivo** los vuelve:

-   DifÃ­ciles de mantener
    
-   Complicados de reutilizar
    
-   Poco legibles para otros
    

&gt; ğŸ§© Un **mÃ³dulo** es simplemente un archivo `.py` que contiene funciones, clases o variables que puedes **importar desde otros archivos** para organizarlos mejor.

---

### âœ… Ventajas de usar mÃ³dulos

-   Organiza el cÃ³digo por tema o funcionalidad
    
-   Reutiliza cÃ³digo sin copiar y pegar
    
-   Facilita el trabajo en equipo y el mantenimiento
    
-   Da el primer paso para construir **paquetes**
    

---

## ğŸ› ï¸ Â¿QuÃ© se necesita para crear un mÃ³dulo?

1.  âœ… Un archivo `.py` que contiene funciones, variables o clases.
    
2.  âœ… Un nombre claro y sin espacios (`fasta_utils.py`, `bio_stats.py`, etc.)
    
3.  âœ… Un uso explÃ­cito de `import` para acceder desde otros scripts.
    
4.  ğŸ“„ DocumentaciÃ³n breve en forma de docstrings.
    
5.  âŒ No tener cÃ³digo ejecutable suelto (idealmente sin `print()`s fuera de funciones).
    

---


``` python
# nombre_modulo.py

"""
Docstring del mÃ³dulo: explica quÃ© contiene y para quÃ© sirve.
"""

# 1. Importaciones necesarias
import os
from pathlib import Path

# 2. Constantes (si aplica)
BASES_VALIDAS = {"A", "T", "G", "C"}

# 3. Funciones o clases
def mi_funcion(x):
    """DescripciÃ³n de la funciÃ³n"""
    return x * 2

# 4. (Opcional) CÃ³digo de prueba o demostraciÃ³n
if __name__ == "__main__":
    print(mi_funcion(5))
```

---
### ğŸ“¦ Â¿CÃ³mo se usa?

Supongamos que tienes un archivo llamado `fasta_utils.py` con esta funciÃ³n:



``` python
# fasta_utils.py
def leer_fasta(path):
    ...
```

En otro archivo, puedes usarla asÃ­:



``` python
from fasta_utils import leer_fasta

secuencias = leer_fasta("data/secuencias.fasta")
```

---
## ğŸ§© AnÃ¡lisis del programa actual

### ğŸ” Â¿QuÃ© hace el programa?

--

-   **Entrada**: Lee un archivo FASTA con secuencias de ADN
    
-   **ValidaciÃ³n**: Verifica que solo tenga bases A, T, G, C
    
-   **Procesamiento**:
    
    -   Cuenta bases
        
    -   Calcula contenido GC
        
-   **Salida**: Exporta un archivo `.tsv`
    
-   **Pruebas**: Contiene pruebas con `assert`

---

### ğŸ“¦ Propuesta de divisiÃ³n en mÃ³dulos del proyecto

| MÃ³dulo               | Funciones incluidas                             | PropÃ³sito                                                             |
|----------------------|--------------------------------------------------|----------------------------------------------------------------------|
| `fasta_utils.py`   | `leer_fasta()`                                   | Leer y cargar secuencias desde archivos en formato FASTA            |
| `validador.py`       | `validar_secuencia()`                            | Validar que las secuencias contengan solo bases A, T, G y C          |
| `bioestadisticas.py` | `contar_bases()`, `calcular_gc()`                | Calcular frecuencias de bases y contenido GC                         |
| `exportador.py`      | `exportar_tsv()`                                 | Exportar resultados del anÃ¡lisis a archivo `.tsv`                    |
| `analizador.py`      | Uso de los mÃ³dulos anteriores para ejecutar todo | Coordinar lectura, validaciÃ³n, anÃ¡lisis y exportaciÃ³n               |
| `test_analizador.py` | Pruebas con `assert` o `unittest`                | Verificar que las funciones de cada mÃ³dulo se comporten correctamente  |

---
## Actividad

&gt; Separa las funciones y Generar todos los mÃ³dulos.

```
analizador_genomico/              â† Carpeta raÃ­z del proyecto
â”œâ”€â”€ data/                         â† Entrada: archivos FASTA
â”‚   â””â”€â”€ secuencias.fasta
â”‚
â”œâ”€â”€ salida/                       â† Salida: archivos de resultados
â”‚   â””â”€â”€ resultados.tsv
â”‚
â”œâ”€â”€ fasta_utils.py               â† MÃ³dulo: lectura y manejo de archivos FASTA
â”œâ”€â”€ validador.py                 â† MÃ³dulo: validaciÃ³n de secuencias
â”œâ”€â”€ bioestadisticas.py           â† MÃ³dulo: conteo de bases y cÃ¡lculo GC
â”œâ”€â”€ exportador.py                â† MÃ³dulo: exportaciÃ³n a archivo
â”œâ”€â”€ analizador.py                â† Script principal (orquestador del flujo)
â”‚
â”œâ”€â”€ test_analizador.py           â† Pruebas con assert o unittest
â”‚
â”œâ”€â”€ README.md                    â† DescripciÃ³n general del proyecto
â””â”€â”€ detalles_proyecto.md         â† Objetivo, estructura y formatos
```

--

&gt; Si. no logras terminarlo descarga `analizador_genomico_modulos.zip`. (puedes renombrar tu carpeta actual y copiar la nueva. O puedes borrar el actual proyecto y copiar la nueva)

---
## â–¶ï¸ 1. Ejecutar desde la terminal

Estando en la carpeta `analizador_genomico/`, simplemente:


``` python
python analizador.py
```

Este comando:

-   ImportarÃ¡ funciones de los mÃ³dulos `.py` vecinos
    
-   LeerÃ¡ `data/secuencias.fasta`
    
-   GuardarÃ¡ `salida/resultados.tsv`

---
## AÃ±adiendo funcionalidades

Quieres un script `guardar_secuencias.py` que formatee de fasta a tsv. Entonces :

-   Lee el archivo `data/secuencias.fasta`
-   Genera un archivo `salida/secuencias.tsv` con dos columnas: `ID` y `Secuencia`

&gt; Descarga y mueve a tu proyecto `guardar_secuencias.py`
&gt; Ejecutalo

---
## âš ï¸ Nota importante

Si ejecutas el script desde otro directorio (por ejemplo, usando VSCode o desde una notebook en otra carpeta), Python no encontrarÃ¡ los mÃ³dulos.

Soluciones:

- Ejecutar siempre desde la raÃ­z del proyecto

- AÃ±adir el path manualmente a sys.path

- O mejor aÃºn, convertir el proyecto en paquete.

---
## ğŸ§  Â¿QuÃ© es `sys.path`?

Es una **lista de rutas** que Python examina cuando haces un `import`. Si el mÃ³dulo no estÃ¡ en ninguna de esas rutas, verÃ¡s un error `ModuleNotFoundError: No module named 'fasta_utils'`


** âœ… Â¿CÃ³mo aÃ±adir una ruta a `sys.path`? **

SupÃ³n que estÃ¡s en otro directorio y quieres importar desde `analizador_genomico/`:


``` python
import sys
sys.path.append("ruta/a/analizador_genomico")
from fasta_utils import leer_fasta
```

---
## ğŸ›‘ RecomendaciÃ³n

- ğŸ‘‰ Solo usa `sys.path.append()` en scripts o notebooks de desarrollo temporal. 

- Para proyectos formales o producciÃ³n, **mejor estructura el cÃ³digo como paquete**.

---

### âš ï¸ Â¿Por quÃ© `analizador.py` necesita tratarse de forma distinta?

Todos los mÃ³dulos que hemos creado (`fasta_utils.py`, `validador.py`, etc.) **contienen exclusivamente funciones**.  

Sin embargo, `analizador.py` es diferente: **contiene el flujo principal del programa**, es decir, **es el script que ejecuta** todo el anÃ¡lisis llamando a los demÃ¡s mÃ³dulos.

&gt; ğŸ›‘ A simple vista, todos los archivos `.py` parecen ser "mÃ³dulos" reutilizables.  
Esto puede llevar a que **otro programador, sin conocer los detalles, intente importar `analizador.py` como si fuera un mÃ³dulo mÃ¡s**. Â¿QuÃ© pasarÃ­a?

---
## ejemplo

1. Tienes un modulo llamado `saludo.py`


``` python
def hola():
    print("Hola")
```

2. y tienes un programa que usa ese mÃ³dulo


``` python
from saludo import hola

nombre = "Aby"
```

3. QuÃ© pasa si al mÃ³dulo `saludo.py` le agregamos una lÃ­nea fuera de la funciÃ³n


``` python
print("mundo")
```

---

### âŒ Â¿QuÃ© sucede si `analizador.py` tiene cÃ³digo suelto (fuera de funciones)?

Si el archivo contiene instrucciones directamente ejecutables (por ejemplo, lectura de archivos, impresiÃ³n, procesamiento), estas **se ejecutarÃ¡n automÃ¡ticamente al hacer el import**, incluso si solo se querÃ­a acceder a una funciÃ³n.

Esto puede provocar:

-   â— Procesos inesperados (lectura de archivos, ejecuciÃ³n completa)
    
-   â— Resultados incorrectos o repetidos
    
-   â— Dificultades para probar, extender o reutilizar el cÃ³digo

---
## âœ… Â¿CÃ³mo evitamos esto?

La soluciÃ³n es **encapsular el flujo del anÃ¡lisis dentro de una funciÃ³n `main()`** y protegerlo con:


``` python
if __name__ == "__main__":
    main()
```


---
## ğŸ§  Â¿QuÃ© significa `__name__` ?

- `__name__` es una **variable especial incorporada** (built-in) en cada archivo `.py` que se ejecuta o importa.  

- Su valor **depende del contexto** en el que se estÃ¡ ejecutando el archivo.


#### ğŸ§ª TÃ©cnicamente: Â¿QuÃ© valor tiene `__name__`?

| Contexto de ejecuciÃ³n                  | Valor de `__name__`  |
|----------------------------------------|-----------------------|
| Ejecutas el archivo directamente       | `"__main__"`         |
| Importas el archivo desde otro script  | Nombre del archivo (sin `.py`) |


---
## Ejemplo

1.  Agrega la siguiente linea de cÃ³digo al final del programa `analizador.py`


``` python
print(f"__name__ vale: {__name__}")
```

Desde la linea de comando, corre el programa analizador y tiene que imprimir 


``` bash
% python analizador.py 

[OK] Resultados guardados en: output/resultados.tsv
__name__ vale: __main__
```

---
## Ejemplo

Ahora, creemo un script que se llame `llama_analizador.py` que tenga las siguientes lÃ­neas de cÃ³digo:



``` python
import analizador  # estamos importanto analizador como mÃ³dulo

x = 10
```

Y ejecuta en `llama_analizador.py` , te debe regresar esto:



``` python
% python llama_analizador.py

[OK] Resultados guardados en: output/resultados.tsv
__name__ vale: analizador
```

**Â¿CuÃ¡l es el valor de __name__?**

---
## ğŸ¯ Â¿Para quÃ© sirve?

Permite diferenciar entre:

-   ğŸ‘¨â€ğŸ’» **Ejecutar un archivo como programa principal**
    
-   ğŸ§© **Importarlo como mÃ³dulo en otro script**
    

Por eso usamos esta estructura:


``` python
if __name__ == "__main__":
    main()
```

AsÃ­ controlamos **cuÃ¡ndo** debe ejecutarse el flujo principal del programa.

---
## Ejercicio

1. Actualiza el programa `analizador.py` Usando esta estructura estÃ¡ndar:


``` python
def main():
    # CÃ³digo del anÃ¡lisis (leer, validar, calcular, exportar)

if __name__ == "__main__":
    main()
```

2. Vuelve a correr 

```bash
% python analizador.py 
% python llama_analizador.py
```

--

&gt; Si no has terminado copia el archivo `analizador2.py`

---

## ğŸ§© MÃ³dulo --&gt; Paquete ??

** âœ… SeÃ±ales claras de que es buen momento para convertir tu proyecto en paquete **

| SituaciÃ³n                                           | Â¿Conviene empaquetar? |
|----------------------------------------------------|------------------------|
| Ya tienes mÃ³dulos reutilizables (`*.py`)           | âœ”ï¸ SÃ­                   |
| Planeas usar el cÃ³digo en varios proyectos         | âœ”ï¸ SÃ­                   |
| Lo vas a compartir pÃºblicamente o en equipo        | âœ”ï¸ SÃ­                   |
| Solo es un script puntual con lÃ³gica especÃ­fica    | âŒ No                  |

--

#### QuÃ© hacer?

- Convertirlo en un paquete con subcarpetas (`__init__.py`)
- Mover los mÃ³dulos a la carpeta `src/paquete/` (p.e. `src/analizador/`)
- Usar `setup.py` o `pyproject.toml` para instalaciÃ³n
- AÃ±adir `notebooks/` para visualizaciÃ³n o pruebas interactivas
    
---
## ğŸ§± Estructura final de un paquete bÃ¡sico

```
analizador_genomico/             â† Carpeta raÃ­z del proyecto
â”œâ”€â”€ src/                         â† CÃ³digo fuente del paquete
â”‚   â””â”€â”€ analizador/              â† Nombre del paquete (import analizador)
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ fasta_utils.py
â”‚       â”œâ”€â”€ validador.py
â”‚       â”œâ”€â”€ bioestadisticas.py
â”‚       â””â”€â”€ exportador.py
â”‚
â”œâ”€â”€ analizador.py                â† Script ejecutable
â”œâ”€â”€ guardar_secuencias.py        â† Script ejecutable
â”œâ”€â”€ tests/                       â† Carpeta para pruebas
â”‚   â””â”€â”€ test_analizador.py
â”‚
â”œâ”€â”€ data/                        â† Entrada: FASTA
â”œâ”€â”€ output/                      â† Salida: resultados
â”‚
â”œâ”€â”€ README.md
â”œâ”€â”€ detalles_proyecto.md
â”œâ”€â”€ pyproject.toml               â† âš™ï¸ ConfiguraciÃ³n moderna del paquete
â””â”€â”€ setup.cfg                    â† (opcional) ConfiguraciÃ³n extendida
```

---
## ğŸ§  Â¿QuÃ© es `__init__.py`?

Es un **archivo especial** que se coloca dentro de un directorio para decirle a Python:

&gt; â€œğŸ’¡ Esta carpeta debe tratarse como un paquete Python.â€

--

| PropÃ³sito                                | DescripciÃ³n                                                                 |
|------------------------------------------|-----------------------------------------------------------------------------|
| ğŸ§­ Habilita el paquete                   | Python reconocerÃ¡ la carpeta como un paquete vÃ¡lido                        |
| ğŸ“‚ Permite importar mÃ³dulos internos     | Puedes hacer `from mi_paquete import modulo`                               |
| ğŸ§± Define quÃ© se exporta por defecto     | Puedes controlar quÃ© se importa con `from paquete import *` usando `__all__` |
| ğŸ§ª CÃ³digo de inicializaciÃ³n (opcional)   | Puedes ejecutar cÃ³digo cuando el paquete se importa por primera vez        |

---

## âœï¸ Contenido tÃ­pico

-   Puede estar vacÃ­o (`pass`)
    
-   O tener un docstring:

```
"""Este paquete contiene herramientas para analizar secuencias genÃ³micas."""
```

-   O inicializar cosas si se requiere

---
## ğŸ“„ `pyproject.toml`

Es el **archivo principal de configuraciÃ³n de un proyecto Python moderno**.  
Define cÃ³mo se debe construir, instalar y empaquetar tu proyecto.

### ğŸ§  Â¿Para quÃ© sirve?

-   Especifica:
    
    -   Nombre del proyecto
    -   VersiÃ³n
    -   Autor(es)
    -   Requisitos de Python
    -   Dependencias (`dependencies = []`)
        
-   Define el sistema de construcciÃ³n (`setuptools`, `flit`, `poetry`, etc.). ğŸ”§ setuptools es el motor que construye, empaqueta e instala tu proyecto
    
-   Es el **reemplazo moderno de `setup.py`**

---
## ğŸ“„ `setup.cfg`

Es un archivo opcional para **definir metadatos y configuraciones adicionales**.  
Se usa junto con `pyproject.toml` para separar la configuraciÃ³n del cÃ³digo Python.

### ğŸ§  Â¿Para quÃ© sirve?

-   Describe el paquete
    
-   Declara los paquetes y mÃ³dulos a incluir
    
-   Define la versiÃ³n mÃ­nima de Python
    
-   Permite usar `setuptools` sin cÃ³digo en `setup.py`

---
## QuÃ© pasa si ejecuto `analizador.py`

**Â¿Puedo ejecutar el paquete sin instalarlo?** Si corres `analizador.py` no encontrarÃ¡ los paquetes.

Â¿QuÃ© hacer? necesitas agregar la carpeta src/ al sys.path.


``` python
# analizador.py (ubicado en la raÃ­z del proyecto)

import sys
from pathlib import Path

# Agrega la carpeta src al path
sys.path.append(str(Path(__file__).resolve().parent / "src"))

# Ahora puedes importar tu paquete
from analizador.fasta_utils import leer_fasta
```

---
## ğŸ§© Â¿QuÃ© hace?


``` python
# Agrega la carpeta src al path
sys.path.append(str(Path(__file__).resolve().parent / "src"))
```


- **`Path(__file__)`**	: Obtiene la ruta del archivo actual (`analizador.py`) como objeto `Path`
- **`.resolve()`**	: Convierte esa ruta en una **ruta absoluta** (resuelve `..`, `.`)
- **`.parent`**	: Obtiene el directorio que **contiene** ese archivo (el directorio raÃ­z del proyecto)
- **`Path(...) / "src"`**	: Une la ruta del directorio raÃ­z con `"src"` â†’ construye la ruta completa a `src/`
- **`str(...)`** : Convierte ese `Path` en una cadena de texto, que es lo que `sys.path.append()` espera
- **`sys.path.append(...)`**	: Agrega esa ruta a la lista de bÃºsqueda de mÃ³dulos de Python (`sys.path`)


Corre `analizador.py` **funciona**?

---

## ğŸ› ï¸ El problema

Tienes un archivo llamado `analizador.py` en la raÃ­z, y tambiÃ©n una carpeta llamada `analizador` dentro de `src/`.  

Python ve primero el archivo `analizador.py` y **lo confunde con un paquete**, lo cual **rompe la importaciÃ³n**.

&gt; ğŸ”„ Cambia el nombre del archivo `analizador.py` a, por ejemplo, `main.py` o `run.py`. Esto evitarÃ¡ el conflicto de nombres, y **la importaciÃ³n desde `src/analizador/` funcionarÃ¡ perfectamente**.


**Â¿FuncionÃ³??**

---
## Â¿CÃ³mo instalar tu paquete local en modo editable con pip?

#### 1. AsegÃºrate de tener esta estructura mÃ­nima,  vista anteriormente.
#### 2. Abre una terminal y cambia al directorio raÃ­z del proyecto
#### 3. Instala el paquete en modo *editable*

```bash
pip install -e .
```

Esto permite que cualquier cambio que hagas en `src/analizador/` se refleje sin necesidad de reinstalar.

---

### ğŸ§ª 4. Verifica que todo estÃ¡ bien

Desde cualquier parte, abre Python y ejecuta:


``` python
from analizador.fasta_utils import leer_fasta

seqf = "seq.dna"
secuencias = leer_fasta(seqf)

print(secuencias)
```

âœ… Si no hay errores, Â¡tu paquete estÃ¡ funcionando!

### ğŸ§¼ 5. RecomendaciÃ³n

Una vez instalado el paquete con `pip install -e .`, puedes eliminar cualquier lÃ­nea como:


``` python
sys.path.append(...)
```


---
## âœ… Conclusiones principales

-   `import` permite **reutilizar cÃ³digo** desde otros archivos o librerÃ­as.
    
-   Un **mÃ³dulo** es un archivo `.py` con funciones que puedes importar.
    
-   Un **paquete** es una carpeta con mÃ³dulos y un `__init__.py`.
    
-   Usa `main()` y `if __name__ == "__main__"` para **controlar cuÃ¡ndo se ejecuta el programa**.
    
-   `__name__` es `"__main__"` solo si el archivo se ejecuta directamente.
    
-   `__init__.py` activa el paquete y puede definirse configuraciones iniciales.
    
-   `setuptools` se usa para **construir e instalar** tu paquete.
    
-   Con `pip install -e .` puedes usar tu cÃ³digo como paquete sin moverlo.
    
-   El uso correcto de mÃ³dulos y paquetes hace tu cÃ³digo **mÃ¡s limpio, reutilizable y profesional**.


---

## ğŸš€ Funcionalidades avanzadas con paquetes

-   âœ… **DistribuciÃ³n e instalaciÃ³n** con `pip` (`.whl`, `.tar.gz`)
-   ğŸ§ª **Pruebas automatizadas** con `unittest`, `pytest`, `tox`
-   ğŸ§© **DefiniciÃ³n de comandos ejecutables** (`console_scripts`)
-   ğŸ§± **Subpaquetes y namespaces** (`paquete.subpaquete.modulo`)
-   ğŸ” **Control de visibilidad** con `__all__` y `__init__.py`
-   ğŸ“¦ **PublicaciÃ³n en PyPI** para compartir con la comunidad
-   ğŸ§¬ **Compatibilidad con entornos virtuales** y `venv`
-   ğŸ“ **InclusiÃ³n de archivos no Python** (datos, plantillas, scripts)
-   ğŸ” **IntegraciÃ³n continua (CI)** con GitHub Actions, GitLab CI, etc.
-   ğŸ“‘ **DocumentaciÃ³n automÃ¡tica** con `Sphinx` o `MkDocs`
-   ğŸ—‚ï¸ **OrganizaciÃ³n multi-paquete** en proyectos grandes (monorepo)
-   ğŸ”„ **Interoperabilidad con C/C++** usando extensiones compiladas (`.so`, `.pyd`)
-   ğŸ§° **Soporte para plugins** mediante `entry_points`
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
