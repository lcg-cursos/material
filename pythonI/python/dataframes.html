<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Python II y GitHub</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Python II y GitHub
]
.institute[
### Licenciatura en Ciencias Gen√≥micas,UNAM
]
.date[
### First version: yyy-mm-dd; Last update: 2025-05-07
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;


## üéØ Objetivo

Comprender y aplicar la biblioteca pandas de Python para el an√°lisis de datos estructurados mediante el uso de DataFrames, permitiendo la exploraci√≥n, limpieza, transformaci√≥n y an√°lisis de archivos comunes en bioinform√°tica, como GFF3, TSV y CSV.

---
# Introducci√≥n a Pandas y los DataFrames

# üêº ¬øQu√© es pandas?

**`pandas`** es una **biblioteca de Python** especializada en el manejo y an√°lisis de datos **estructurados** (es decir, organizados en filas y columnas, como tablas).

Fue dise√±ada para ser **r√°pida, flexible y expresiva**, y permite trabajar f√°cilmente con datos tabulares, temporales o jer√°rquicos.

&gt; El nombre viene de "**Panel Data**", un t√©rmino usado en estad√≠stica y econometr√≠a.

---
## ‚úÖ ¬øPor qu√© usar pandas?

-   Permite **leer, escribir, filtrar, agrupar, transformar y visualizar** datos de forma eficiente.
-   Ofrece estructuras potentes como:
    
    -   **`Series`**: listas unidimensionales con √≠ndice.
    -   **`DataFrames`**: tablas bidimensionales (¬°la estrella de pandas!).
        
-   Es compatible con m√∫ltiples formatos de datos: **CSV, Excel, JSON, SQL, Parquet, HDF5**, etc.
-   Es **altamente optimizada** y se integra perfectamente con NumPy, matplotlib, seaborn, scikit-learn, entre otras.

---
## üß∞ Instalaci√≥n

Si no tienes instalada la librer√≠a:

```bash
pip install pandas
```

---
## üß± Estructuras principales de pandas

### üîπ `Series`

Una lista con √≠ndice:

``` python
import pandas as pd

s = pd.Series([10, 20, 30], index=['a', 'b', 'c'])
print(s)
```
---
### üî∏ `DataFrame`

Una tabla con filas y columnas:


``` python
data = {
    'Gene': ['thrL', 'thrA', 'thrB'],
    'Longitud': [117, 2340, 1461]
}

df = pd.DataFrame(data)
print(df)
```

---
### üêº **Dato curioso sobre pandas**

&gt; **¬°pandas puede trabajar con millones de datos sin que uses loops!**

Una de las cosas m√°s sorprendentes para quienes vienen de otros lenguajes o apenas est√°n comenzando en Python es que **`pandas` puede procesar conjuntos de datos enormes (millones de filas) sin necesidad de escribir bucles `for`**.

ü§Ø Por ejemplo, si tienes un archivo con **10 millones de genes simulados** (o lecturas, o variantes), puedes agrupar, filtrar y resumir todo con una sola l√≠nea de c√≥digo, gracias a la **vectorizaci√≥n interna** de pandas.


---
### üí° Comparaci√≥n 


``` python
# En un lenguaje tradicional, har√≠as algo como:
for fila in datos:
    if fila['expresion'] &gt; 1000:
        guardar(fila)

# En pandas basta con:
df[df['expresion'] &gt; 1000]
```
Y esto no solo es m√°s **corto**, tambi√©n es **m√°s r√°pido** porque est√° implementado en **C internamente**. üéØ

---
## üìå ¬øQu√© es un DataFrame?

Un **DataFrame** es una **estructura de datos bidimensional** que forma parte de la biblioteca **pandas** en Python. Est√° dise√±ada para manejar datos de forma tabular, es decir, en **filas y columnas**, similar a una hoja de c√°lculo, una tabla SQL o una tabla de Excel.

### ‚úÖ Un DataFrame puede considerarse como:

-   Una colecci√≥n ordenada de **series** (columnas),
    
-   Cada columna puede tener un tipo de dato distinto (n√∫meros, cadenas, booleanos),
    
-   Tiene **√≠ndices en las filas** y **nombres de columnas**.

---

### üìä Comparativa: DataFrame vs otras estructuras de datos en Python

| Caracter√≠stica               | `list` (Lista)       | `dict` (Diccionario)       | `DataFrame` (`pandas`)           |
|-----------------------------|----------------------|-----------------------------|----------------------------------|
| Dimensi√≥n                   | Unidimensional        | Unidimensional (clave-valor) | Bidimensional (filas y columnas) |
| Soporte tabular             | ‚ùå                   | ‚ùå                          | ‚úÖ                                |
| Tipos de datos por columna  | ‚úÖ                   | ‚úÖ                          | ‚úÖ (cada columna puede tener su tipo) |
| Acceso por etiqueta         | ‚ùå                   | ‚úÖ (claves)                 | ‚úÖ (columnas e √≠ndices)          |
| Indexaci√≥n avanzada         | ‚ùå                   | ‚ùå                          | ‚úÖ (`.loc[]`, `.iloc[]`)         |
| Carga desde archivos        | ‚ùå                   | ‚ùå                          | ‚úÖ (`read_csv`, `read_excel`, etc.) |
| Operaciones vectorizadas    | ‚ùå                   | ‚ùå                          | ‚úÖ                                |
| Filtrado por condiciones    | ‚ùå                   | ‚ùå                          | ‚úÖ (`df[df['col'] &gt; x]`)         |
| Agrupaciones y resumen      | ‚ùå                   | ‚ùå                          | ‚úÖ (`groupby`, `describe`)       |
| Ideal para datos estructurados | ‚ùå                | ‚ùå                          | ‚úÖ                                |
---
## üéì ¬øCu√°ndo deber√≠as usar un DataFrame?

-   Cuando tus datos tienen forma de **tabla**
-   Cuando necesitas **analizar, filtrar, agrupar, transformar o visualizar** informaci√≥n.
-   Cuando trabajas con **grandes vol√∫menes de datos** y necesitas rendimiento.
-   Cuando lees datos desde archivos estructurados como `.csv`, `.tsv`, `.xlsx`, o bases de datos.

---

## üß¨ Aplicaci√≥n en bioinform√°tica

En bioinform√°tica es com√∫n trabajar con datos gen√≥micos que vienen en archivos como `.gff`, `.gtf`, `.csv`, `.bed`, `.tsv`, etc. 

Ejemplos t√≠picos:

-   Tabla de genes: GeneID, nombre, funci√≥n, longitud.
-   Resultados de expresi√≥n g√©nica: GeneID, condici√≥n1, condici√≥n2...
-   Predicciones de reguladores, motivos, puntuaciones...
   
**Un DataFrame es ideal para almacenar, filtrar y analizar estos datos de forma flexible.**

---
## üìò M√©todos comunes de DataFrames (`pandas`)

#### üìä M√©todos para explorar datos

| M√©todo                  | Descripci√≥n                                             |
|------------------------|---------------------------------------------------------|
| `df.head(n)`           | Muestra las primeras `n` filas del DataFrame           |
| `df.tail(n)`           | Muestra las √∫ltimas `n` filas                          |
| `df.shape`             | Devuelve una tupla con (n√∫mero de filas, columnas)     |
| `df.columns`           | Lista los nombres de las columnas                      |
| `df.info()`            | Informaci√≥n general del DataFrame (columnas, tipos, nulos) |
| `df.describe()`        | Estad√≠sticas descriptivas de columnas num√©ricas        |
| `df.dtypes`            | Tipo de dato de cada columna                           |


---
#### üîç M√©todos para seleccionar y filtrar

| M√©todo                      | Descripci√≥n                                       |
|----------------------------|---------------------------------------------------|
| `df['columna']`            | Acceder a una columna                            |
| `df[['col1', 'col2']]`     | Acceder a varias columnas                        |
| `df.loc[fila]`             | Acceder a una fila por etiqueta de √≠ndice        |
| `df.iloc[pos]`             | Acceder a una fila por posici√≥n num√©rica         |
| `df[df['col'] &gt; valor]`    | Filtrado por condici√≥n booleana                  |

---
#### üîÑ M√©todos para transformar o modificar

| M√©todo                         | Descripci√≥n                                     |
|-------------------------------|-------------------------------------------------|
| `df['nueva'] = ...`           | Crear o modificar una columna                   |
| `df.drop()`                   | Eliminar columnas o filas                       |
| `df.rename()`                 | Renombrar columnas                              |
| `df.apply(funci√≥n)`           | Aplicar una funci√≥n personalizada a columnas o filas |
| `df.replace()`                | Reemplazar valores       

---
#### üìö M√©todos √∫tiles en bioinform√°tica

| M√©todo                         | Descripci√≥n                                     |
|-------------------------------|-------------------------------------------------|
| `df.groupby()`                | Agrupar datos por una columna y resumir        |
| `df.merge()`                 | Combinar dos DataFrames por una columna com√∫n  |
| `df.sort_values()`            | Ordenar el DataFrame por valores                |
| `df.isnull()` / `df.fillna()` | Identificar o rellenar valores nulos           |
| `df.to_csv()` / `read_csv()`  | Exportar o leer archivos CSV/TSV               |


---
## üß∞ Sintaxis B√°sica de los DataFrames

**Crear un DataFrame desde un diccionario**


``` python
import pandas as pd

data = {
    'Columna1': [valor1, valor2, valor3],
    'Columna2': [valorA, valorB, valorC]
}

df = pd.DataFrame(data) # de diccionario --&gt; dataframe
```

‚úÖ **Explicaci√≥n**:

-   Cada clave del diccionario es una columna.
-   Cada lista contiene los valores de esa columna.
-   `df` es ahora un DataFrame que puedes manipular.

---

## Ejemplo


``` python
import pandas as pd

data = {
    'Nombre': ['Ana', 'Luis', 'Sof√≠a'],
    'Edad': [28, 34, 22],
    'Ciudad': ['CDMX', 'Guadalajara', 'Monterrey']
}

df = pd.DataFrame(data)
print(df)
```

Resultado:

```css
    Nombre   Edad      Ciudad
0   Ana      28        CDMX
1   Luis     34        Guadalajara
2   Sof√≠a    22        Monterrey
```


üëâ F√≠jate que los √≠ndices (0, 1, 2) se generan autom√°ticamente, pero tambi√©n pueden personalizarse.

---
### üìå Operaciones b√°sicas con DataFrames

#### Acceder a columnas:


``` python
df['Edad']              # Acceder a una sola columna
df[['Nombre', 'Edad']]  # Acceder a varias columnas
```

--

#### Acceder a una fila por √≠ndice:


``` python
df.loc[1]    # Accede a la fila con etiqueta de √≠ndice 1
df.iloc[2]   # Accede a la tercera fila (posici√≥n 2)
```

---

#### Filtrado (por condici√≥n):


``` python
df[df['Edad'] &gt; 25]
```

--

#### Agregar una nueva columna:


``` python
df['Ocupaci√≥n'] = ['Bi√≥loga', 'Ingeniero', 'Estudiante']
```

---
### Ejemplo con Genes

Supongamos que tienes una tabla con informaci√≥n de genes:


``` python
genes = {
    'GeneID': ['b0001', 'b0002', 'b0003'],
    'Nombre': ['thrL', 'thrA', 'thrB'],
    'Funci√≥n': ['regulador', 'enzima', 'enzima'],
    'Longitud': [117, 2340, 1461]
}

df_genes = pd.DataFrame(genes)
```

---

**Filtrado por una condici√≥n**


``` python
# Genes cuya longitud es mayor a 1000 pb
df[df['Longitud'] &gt; 1000]

# Genes cuya funci√≥n es "enzima"
df[df['Funci√≥n'] == 'enzima']

# Genes cuya expresi√≥n es menor a 30
df[df['Expresi√≥n'] &lt; 30]
```

**Filtrado compuesto**


``` python
# Genes de funci√≥n 'enzima' y longitud mayor a 1500
df[(df['Funci√≥n'] == 'enzima') &amp; (df['Longitud'] &gt; 1500)]

# Genes que NO son enzimas
df[df['Funci√≥n'] != 'enzima']
```

---

**Seleccionar columnas despu√©s de un filtro**


``` python
# Mostrar solo Nombre y Expresi√≥n de genes con expresi√≥n alta
df[df['Expresi√≥n'] &gt; 40][['Nombre', 'Expresi√≥n']]
```

** Usar  `.loc[]` con condiciones y selecci√≥n**


``` python
# Mostrar GeneID y Funci√≥n de genes con longitud &gt; 1000
df.loc[df['Longitud'] &gt; 1000, ['GeneID', 'Funci√≥n']]
```

**Usar `.iloc[]` para seleccionar por posici√≥n**


``` python
# Mostrar las dos primeras filas
df.iloc[:2]
```

**Crear una nueva columna con condiciones**


``` python
df['Es_largo'] = df['Longitud'] &gt; 1000
print(df)
```

‚úÖ Aqu√≠ se crea una columna booleana que indica si el gen es largo.

---

### Resumen de filtrado

| Expresi√≥n                         | Descripci√≥n                                                                 |
|----------------------------------|----------------------------------------------|
| `df['columna']`                  | Acceder a una sola columna                                                 |
| `df[['col1', 'col2']]`           | Acceder a varias columnas                                                  |
| `df.loc[fila]`                   | Acceder a una fila usando la etiqueta de √≠ndice                           |
| `df.iloc[pos]`                   | Acceder a una fila por posici√≥n num√©rica (basado en la posici√≥n)          |
| `df[df['col'] &gt; valor]`          | Filtrar filas con valores mayores a cierto umbral                         |
| `df[df['col'] == 'valor']`       | Filtrar filas que cumplen una condici√≥n exacta                            |
| `df[df['col'] != 'valor']`       | Filtrar filas que no cumplen con un valor espec√≠fico                      |
| `df[(cond1) &amp; (cond2)]`          | Filtrar con m√∫ltiples condiciones (AND l√≥gico)                            |
| `df[(cond1) | (cond2)]`          | Filtrar con m√∫ltiples condiciones (OR l√≥gico)                             |
| `df.loc[condici√≥n, ['col']]`     | Filtrar con condici√≥n y seleccionar columnas espec√≠ficas con `.loc[]`     |
| `df.iloc[filas, columnas]`       | Seleccionar filas y columnas por posici√≥n con `.iloc[]`                   |
| `df['nueva'] = condici√≥n`        | Crear una nueva columna a partir de una condici√≥n                         |
| `df['col'].apply(funci√≥n)`       | Aplicar una funci√≥n a una columna                                          |

---

## Otras formas comunes de crear un DataFrame:

###  Desde una lista de diccionarios:


``` python
data = [
    {'nombre': 'Ana', 'edad': 25},
    {'nombre': 'Luis', 'edad': 30}
]
df = pd.DataFrame(data)
```



### Desde un archivo:


``` python
df = pd.read_csv("archivo.csv")
```
---

## Caso:  Exploraci√≥n y an√°lisis del archivo de genes `genes.gff3`

### Archivo de Entrada

Guarda esto como un archivo de texto llamado **`genes.gff3`**:

```
##gff-version 3
NC_000913.3	RefSeq	gene	190	255	.	+	.	ID=gene-b0001;Name=thrL
NC_000913.3	RefSeq	gene	337	2799	.	+	.	ID=gene-b0002;Name=thrA
NC_000913.3	RefSeq	gene	2550	4030	.	-	.	ID=gene-b0003;Name=thrB
NC_000913.3	RefSeq	gene	5000	6000	.	+	.	ID=gene-b0004;Name=yaaX
NC_000913.3	RefSeq	gene	6300	7100	.	-	.	ID=gene-b0005;Name=yaaY
NC_000913.3	RefSeq	gene	9000	8500	.	-	.	ID=gene-b0006;Name=malFormado
```

---
## üìò M√©todo `pd.read_csv()`

`pd.read_csv()` es uno de los m√©todos m√°s importantes y utilizados de la biblioteca `pandas`. Sirve para **leer archivos de texto con datos estructurados**, como archivos **CSV** (valores separados por comas), **TSV** (por tabulaciones), o incluso **archivos bioinform√°ticos como GFF, BED o VCF** (cuando se adaptan sus columnas).

Es la **puerta de entrada para convertir un archivo plano en un DataFrame**, lo que permite explorar, filtrar, analizar y visualizar los datos f√°cilmente desde Python.

### ‚úÖ **Sintaxis general**


``` python
pd.read_csv(filepath_or_buffer, sep=',', header='infer', names=None, comment=None, usecols=None, dtype=None, na_values=None, ...)
```

---
### ‚öôÔ∏è **Ejemplo**


``` python
import pandas as pd

# Leer archivo GFF3 ignorando comentarios
df = pd.read_csv(
    "genes.gff3",
    sep="\t",                # Separador tabulado
    comment="#",             # Ignorar l√≠neas que comienzan con #
    header=None,             # No hay cabecera en el archivo
    names=["seqid", "source", "type", "start", "end", "score", "strand", "phase", "attributes"]
)

print(df)
```

---
## üîß M√©todos para **explorar** un DataFrame 

**`.head()`** : El m√©todo `.head()` permite **visualizar las primeras filas** de un DataFrame. Es una herramienta muy √∫til durante la **exploraci√≥n inicial de datos**, para comprobar c√≥mo se cargaron las columnas, qu√© valores hay y si la estructura es la esperada.

 **`df.tail(n)`** : Muestra las **√∫ltimas `n` filas** del DataFrame. √ötil para ver si hay filas incompletas o mal formateadas al final.

** ‚úÖ Sintaxis: **


``` python
df.head(n) # `n`: n√∫mero de filas a mostrar (por defecto 5)
```
  

**Ejemplo**


``` python
print(df.head(3))
print(df.tail(3))
```

---

**`.info()` **:  Muestra un **resumen de la estructura** del DataFrame: columnas, tipos de datos, valores nulos y uso de memoria.

#### ‚úÖ Sintaxis:


``` python
df.info()
```

**`.describe()` ** Calcula **estad√≠sticas descriptivas** para columnas num√©ricas: media, desviaci√≥n, min, max, percentiles...

 ‚úÖ Sintaxis:


``` python
df.describe()
```

---

** `df.shape` **

**üîé ¬øQu√© hace?**  
Devuelve una tupla `(n_filas, n_columnas)` que indica la **dimensi√≥n** del DataFrame.

**‚úÖ Sintaxis:**


``` python
df.shape
```

#### Ejemplo 


``` python
print("N√∫mero de filas y columnas:", df.shape)
```

---

**`df.columns` **:  Devuelve una lista con los **nombres de las columnas**. √ötil para verificar que las cabeceras est√°n correctas.

**‚úÖ Sintaxis:**


``` python
df.columns
```

---
### üîÅ Recomendaci√≥n pr√°ctica para estudiantes

Cuando usas un notebook, es recomendable  justo despu√©s de cargar tus datos, siempre ejecuta:


``` python
df.head()
df.info()
df.describe()
```

Esto te da un **panorama general** de c√≥mo est√°n estructurados los datos.

Pero si el dataframe forma parte de un programa (que no es un notebook), es recomendable explorar tus datos previo a cargarlos.

---
## Ejemplo : **An√°lisis de expresi√≥n g√©nica**

Tienes un archivo `expresion_genica.tsv` con los siguientes datos (separados por tabulador):

```
gene_id	cond1	cond2	cond3
b0001	55	80	70
b0002	1500	2000	1800
b0003	100	95	120
b0004	2300	2500	2100
```

**Objetivo:**

1.  Identificar genes altamente expresados (mayores a 1000) en las tres condiciones.
2.  Calcular el promedio de expresi√≥n por gen.
3.  Ordenar de mayor a menor por promedio.
4.  Exportar el resultado.


---
## Ejemplo : **An√°lisis de expresi√≥n g√©nica**



``` python
import pandas as pd
```

--

- Leer el archivo


``` python
df = pd.read_csv("expresion_genica.tsv", sep="\t")
```

--

- Filtrar genes con expresi√≥n &gt; 1000 en las 3 condiciones


``` python
altos = df[(df['cond1'] &gt; 1000) &amp; (df['cond2'] &gt; 1000) &amp; (df['cond3'] &gt; 1000)]
```

--

- Calcular promedio por fila


``` python
altos['promedio'] = altos[['cond1', 'cond2', 'cond3']].mean(axis=1)
```

---
## Ejemplo : **An√°lisis de expresi√≥n g√©nica**

- Ordenar de mayor a menor


``` python
altos = altos.sort_values(by='promedio', ascending=False)
```

- Exportar


``` python
altos.to_csv("genes_altamente_expresados.tsv", sep="\t", index=False)
```

---
## üîß M√©todos para **transformar o modificar** un DataFrame en `pandas`.

Una vez que exploramos y filtramos los datos, el siguiente paso en el an√°lisis es **modificarlos**. Esto puede implicar:

-   Cambiar nombres de columnas
-   Reemplazar valores
-   Eliminar o agregar columnas/filas
-   Cambiar el tipo de datos
-   Aplicar funciones a columnas o filas
-   Reorganizar el DataFrame


---
## Caso Pr√°ctico: An√°lisis de Informaci√≥n Gen√©tica 

Eres parte de un laboratorio de gen√©tica que est√° analizando informaci√≥n de genes bacterianos almacenados en un archivo llamado `genes.csv`. 

Este archivo contiene datos sobre identificadores de genes, nombres, funciones biol√≥gicas, longitud en pares de bases y niveles de expresi√≥n.

Tu tarea es **realizar una serie de transformaciones al conjunto de datos para facilitar su an√°lisis y visualizaci√≥n**. A continuaci√≥n, aprender√°s c√≥mo modificar este `DataFrame` usando herramientas de `pandas`.

---

## üì• Paso 1: Cargar los datos


``` python
import pandas as pd

df = pd.read_csv('genes.csv')
print(df.head())
```

üìå **Este archivo contiene:**
```
GeneID,Nombre,Funci√≥n,Longitud,Expresi√≥n
b0001,thrL,regulador,117,20.5
b0002,thrA,enzima,2340,50.2
b0003,thrB,enzima,1461,45.0
b0004,recA,reparaci√≥n,1038,10.1
```

---
### 1. üî§ Cambiar el nombre de una columna

&gt; Queremos que la columna `Funci√≥n` se llame `Tipo_funcional` para que sea m√°s descriptiva.


``` python
df_renombrado = df.rename(columns={'Funci√≥n': 'Tipo_funcional'})
print(df_renombrado.columns)
```

---
### 2. üîÅ Estandarizar valores

&gt; Necesitamos homogeneizar el nombre de las funciones: reemplazar `enzima` por `enzima_metab√≥lica`.


``` python
df_estandarizado = df.replace({'Funci√≥n': {'enzima': 'enzima_metab√≥lica'}})
print(df_estandarizado)
```

---
### 3. ‚ùå Eliminar columnas o filas innecesarias

&gt; Para ciertos an√°lisis no necesitamos la columna `Expresi√≥n`, y eliminaremos tambi√©n una fila duplicada.


``` python
df_sin_col = df.drop(columns=['Expresi√≥n'])  # Eliminar columna
df_sin_fila = df.drop(index=1)              # Eliminar fila con √≠ndice 1
```

---
### 4. üî¢ Asegurar el tipo correcto de datos

&gt; Vamos a asegurarnos de que la columna `Longitud` sea de tipo `float`.


``` python
df['Longitud'] = df['Longitud'].astype(float)
print(df.dtypes)
```


---
### 5. üè∑Ô∏è Clasificaci√≥n de genes por longitud

#### üß© M√©todo: `.apply()` + `lambda`

**¬øQu√© hace `.apply()`?**  
Es un m√©todo que aplica una funci√≥n a cada elemento de una columna o fila de un `DataFrame`. Es muy √∫til para crear nuevas columnas o transformar datos existentes de forma flexible.

**¬øQu√© es `lambda`?**  
Es una forma de definir funciones peque√±as y an√≥nimas (sin nombre). Por ejemplo:}



``` python
lambda x: x + 1
```
es equivalente a:


``` python
def f(x):
    return x + 1
```

---
## Ô∏è Clasificaci√≥n de genes por longitud

Queremos clasificar los genes como **"Largo"** si tienen m√°s de 1000 pb (pares de bases), o **"Corto"** en caso contrario.


``` python
df['Clasificaci√≥n'] = df['Longitud'].apply(lambda x: 'Largo' if x &gt; 1000 else 'Corto')
print(df[['GeneID', 'Longitud', 'Clasificaci√≥n']])
```

üìå **Comentario:** Se a√±ade una nueva columna `Clasificaci√≥n` que indica la longitud relativa de cada gen de forma categ√≥rica.

---

### 6. üßÆ Crear una columna con valores derivados

#### üß© M√©todo: `.assign()` + `.apply()` + `lambda`

**¬øQu√© hace `.assign()`?**  
Crea una nueva columna sin modificar el `DataFrame` original, devolviendo una copia con la columna a√±adida.

**¬øQu√© hacemos aqu√≠?**  
Vamos a derivar una nueva medida: el logaritmo cuadrado (ra√≠z cuadrada) del nivel de expresi√≥n, como una forma de normalizar los valores.


``` python
df_nuevo = df.assign(LogExpresi√≥n=lambda x: x['Expresi√≥n'].apply(lambda val: round(val ** 0.5, 2)))
print(df_nuevo[['GeneID', 'Expresi√≥n', 'LogExpresi√≥n']])
```

üìå **Comentario:** Se crea una nueva columna `LogExpresi√≥n` con valores transformados

---
### 7. üîΩ Ordenar el DataFrame

#### üß© M√©todo: `.sort_values()`

**¬øQu√© hace `.sort_values()`?**  
Ordena un `DataFrame` en funci√≥n de los valores de una columna espec√≠fica. Se puede ordenar ascendente o descendente.

**Aplicaci√≥n en contexto:** Queremos ver primero los genes m√°s largos.


``` python
df_ordenado = df.sort_values(by='Longitud', ascending=False)
print(df_ordenado[['GeneID', 'Longitud']])
```
üìå **Comentario:** El DataFrame queda ordenado desde el gen m√°s largo hasta el m√°s corto seg√∫n la columna `Longitud`.

---
### 8. üîÑ Reiniciar el √≠ndice

#### üß© M√©todo: `.reset_index()`

**¬øQu√© hace `.reset_index()`?**  
Restaura el √≠ndice del `DataFrame` a valores consecutivos (0, 1, 2...). Si hab√≠as eliminado filas o hab√≠as establecido un √≠ndice diferente, esto limpia la numeraci√≥n.

**Opci√≥n `drop=True`:** evita que el √≠ndice anterior quede como una nueva columna.


``` python
df_reset = df.reset_index(drop=True)
print(df_reset.head())
```

---
### 9. üìå Establecer una columna como √≠ndice

#### üß© M√©todo: `.set_index()`

**¬øQu√© hace `.set_index()`?**  
Reemplaza el √≠ndice del `DataFrame` con una columna, lo cual puede facilitar b√∫squedas o agrupamientos.

**Aplicaci√≥n en contexto:** Queremos que el identificador del gen (`GeneID`) sea el √≠ndice principal del `DataFrame`.


``` python
df_indexado = df.set_index('GeneID')
print(df_indexado.head())
```
üìå **Comentario:** Ahora puedes acceder a los datos directamente usando el ID del gen, por ejemplo: `df_indexado.loc['b0002']`.


---

---

## üß™ Ejercicios adicionales: `.apply()` + `lambda`

---
### üß¨ Ejercicio 1: Clasificaci√≥n de expresi√≥n g√©nica

**Contexto:**  
En tu laboratorio, se necesita categorizar los niveles de expresi√≥n g√©nica en `'baja'`, `'media'` o `'alta'`, usando los siguientes criterios:

-   `alta` si la expresi√≥n es mayor a 40
    
-   `media` si es mayor a 15 pero menor o igual a 40
    
-   `baja` si es 15 o menos
    

**Instrucci√≥n:**  
Agrega una nueva columna llamada `"NivelExp"` con esta clasificaci√≥n.

üìå Pista: usa `.apply()` con un `lambda` sobre la columna `Expresi√≥n`.


---

### üß† Ejercicio 2: Clasificaci√≥n funcional

**Contexto:**  
Necesitas clasificar los genes de acuerdo con su funci√≥n:

-   Si la funci√≥n contiene la palabra `'enzima'`, clasif√≠calo como `'Metab√≥lico'`.
    
-   En caso contrario, como `'Otro'`.
    

**Instrucci√≥n:**  
Crea una nueva columna `"Tipo"` que contenga esta clasificaci√≥n.

üìå Pista: usa `.lower()` para que el filtro funcione con may√∫sculas y min√∫sculas.

---
### üß¨ Ejercicio 3: Normalizaci√≥n de identificadores

**Contexto:**  
Para integrar tus datos con otra base, todos los identificadores de gen deben comenzar con el prefijo `"eco_"`.

**Instrucci√≥n:**  
Crea una nueva columna `"GeneID_modificado"` que contenga el ID del gen con el prefijo a√±adido.

üìå Ejemplo: `b0001` ‚Üí `eco_b0001`



---

## üìö M√©todos √∫tiles en bioinform√°tica

Vamos a trabajar con el archivo `genes.csv` que contiene informaci√≥n como:

```
GeneID,Nombre,Funci√≥n,Longitud,Expresi√≥n
b0001,thrL,regulador,117,20.5
b0002,thrA,enzima,2340,50.2
b0003,thrB,enzima,1461,45.0
b0004,recA,reparaci√≥n,1038,10.1
```

---
### 1. üîó `df.groupby()`: Agrupar y resumir datos

**¬øQu√© hace?**  
Permite **agrupar filas** que comparten un mismo valor en una columna y aplicar funciones agregadas (como `mean`, `sum`, `count`, etc.).

**Ejemplo:** ¬øCu√°l es la **media de expresi√≥n** por tipo de funci√≥n?


``` python
import pandas as pd
df = pd.read_csv('genes.csv')

media_por_funcion = df.groupby('Funci√≥n')['Expresi√≥n'].mean()
print(media_por_funcion)
```
üìå **Comentario:** Este m√©todo es muy √∫til para comparar promedios entre clases funcionales de genes.


---
### üß™ Ejemplo 2: N√∫mero de genes por tipo funcional

üéØ **Objetivo:** Contar cu√°ntos genes pertenecen a cada funci√≥n.


``` python
conteo = df.groupby('Funci√≥n')['GeneID'].count()
print(conteo)
```
üìå **Comentario:** √ötil para estad√≠stica descriptiva o ver qu√© procesos dominan en la muestra.


---
### üß™ Ejemplo 3: Longitud promedio por tipo de funci√≥n

üéØ **Objetivo:** Ver si los genes de cierta funci√≥n tienden a ser m√°s largos.


``` python
longitudes = df.groupby('Funci√≥n')['Longitud'].mean()
print(longitudes)
```
üìå **Comentario:** Esto puede sugerir complejidad estructural o funcional.

---
### üß™ Ejemplo 4: Expresi√≥n total por funci√≥n

üéØ **Objetivo:** Ver qu√© grupo funcional tiene mayor impacto global en t√©rminos de expresi√≥n.


``` python
suma_exp = df.groupby('Funci√≥n')['Expresi√≥n'].sum()
print(suma_exp)
```
üìå **Comentario:** Esto da idea de la carga transcripcional total por clase funcional.

---

### üß© ¬øQu√© es `.agg()`?

El m√©todo `.agg()` (abreviaci√≥n de _aggregate_) permite aplicar **una o m√°s funciones de resumen o transformaci√≥n** a uno o varios campos de un `DataFrame`, ya sea agrupado o no.

### üìå Sintaxis general

```
df.agg(funci√≥n)
df.agg([func1, func2, ...])             # m√∫ltiples funciones sobre columnas
df.groupby(columna).agg(func_dict)      # agrupado con funciones por columna
```

---
üî¨ Ejemplo


``` python
import pandas as pd

df = pd.DataFrame({
    'Expresi√≥n': [10, 20, 30, 40]
})

resumen = df.agg(['mean', 'max', 'min'])
print(resumen)
```

```css
Expresi√≥n
mean         25.0
max          40.0
min          10.0
```

---
### üß™ Ejemplo 5: M√∫ltiples funciones estad√≠sticas ( `groupby`  + `agg` )

üéØ **Objetivo:** Obtener estad√≠sticas m√∫ltiples por grupo (`mean`, `max`, `min`).


``` python
resumen = df.groupby('Funci√≥n')['Expresi√≥n'].agg(['mean', 'max', 'min', 'count'])
print(resumen)
```

Esto produce un resumen estad√≠stico por tipo de funci√≥n:

```matlab
               mean   max   min  count
Funci√≥n                               
enzima         31.73 50.2   0.0      3
regulador      20.50 20.5  20.5      1
reparaci√≥n     19.05 28.0  10.1      2
```

---
### üß™ Ejemplo 6: Agrupamiento por m√∫ltiples columnas

üéØ **Objetivo:** Agrupar por dos columnas (ej. funci√≥n y clasificaci√≥n por longitud).



``` python
# A√±adir clasificaci√≥n por longitud
df['Clasificaci√≥n'] = df['Longitud'].apply(lambda x: 'Largo' if x &gt; 1500 else 'Corto')

# Agrupar por Funci√≥n y Clasificaci√≥n
agrupado = df.groupby(['Funci√≥n', 'Clasificaci√≥n'])['GeneID'].count()
print(agrupado)
```
üìå **Comentario:** Se obtienen combinaciones √∫nicas de tipo y tama√±o funcional.


---

## üß™ Ejercicios: Agrupaci√≥n con `groupby()`

---

### üß© Ejercicio 1 (b√°sico): Conteo de genes por funci√≥n

**Objetivo:**  
Determinar cu√°ntos genes hay de cada tipo funcional (por ejemplo: `'enzima'`, `'regulador'`, etc.).

**Instrucci√≥n:**  
Usa `groupby()` para agrupar el DataFrame por la columna `"Funci√≥n"` y contar cu√°ntos genes hay en cada grupo. Muestra el resultado como una serie con la funci√≥n y el conteo.

üìå **Tip:** Usa `.count()` o `.size()`.

---

### üß© Ejercicio 2 (intermedio): Promedio de longitud por funci√≥n

**Objetivo:**  
Comparar el tama√±o promedio de los genes seg√∫n su funci√≥n.

**Instrucci√≥n:**  
Agrupa los datos por `"Funci√≥n"` y calcula la **longitud promedio** usando la columna `"Longitud"`. Muestra los resultados ordenados de mayor a menor.

üìå **Tip:** Usa `.mean()` y luego `.sort_values()`.


---
### üß© Ejercicio 3 (intermedio-avanzado): Estad√≠sticas m√∫ltiples de expresi√≥n

**Objetivo:**  
Obtener un resumen detallado del nivel de expresi√≥n por tipo funcional.

**Instrucci√≥n:**  
Agrupa los datos por `"Funci√≥n"` y calcula:

-   la media (`mean`)
    
-   el valor m√°ximo (`max`)
    
-   el valor m√≠nimo (`min`)
    
-   el n√∫mero de genes (`count`)
    

Presenta el resultado como un `DataFrame` con estas 4 columnas para cada grupo.

üìå **Tip:** Usa `.agg()` pasando una lista de funciones estad√≠sticas.

---





    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
