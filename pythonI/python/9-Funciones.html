<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Python II y GitHub</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Python II y GitHub
]
.institute[
### Licenciatura en Ciencias GenÃ³micas,UNAM
]
.date[
### First version: yyy-mm-dd; Last update: 2025-04-25
]

---





&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;

# ğŸ¯ Objetivo

Comprender el concepto, la utilidad y la sintaxis de las funciones en Python, aplicando buenas prÃ¡cticas de programaciÃ³n.

&lt;img src="https://realpython.com/cdn-cgi/image/width=1920,format=auto/https://files.realpython.com/media/Pythons-Math-Module-Guide_Watermarked.c882e267cbd0.jpg" width="600px" style="display: block; margin: auto;" /&gt;

---
## ğŸ”¹ Â¿Por quÃ© usar funciones en programaciÃ³n?

Cuando escribimos un programa, muchas veces necesitamos **repetir ciertas operaciones** u **organizar el cÃ³digo** para que sea mÃ¡s claro y fÃ¡cil de mantener. AhÃ­ es donde entran las **funciones**.

---

# ğŸ§  Â¿QuÃ© es una funciÃ³n?

Una **funciÃ³n** es un bloque de cÃ³digo reutilizable que recibe entradas (parÃ¡metros), ejecuta instrucciones, y puede retornar un valor.

Nos permite:

-   **Evitar la repeticiÃ³n** de cÃ³digo (principio DRY: _Don't Repeat Yourself_).
    
-   **Dividir un problema complejo** en partes pequeÃ±as, mÃ¡s fÃ¡ciles de entender.
    
-   **Reutilizar** cÃ³digo en distintas partes del programa sin copiar/pegar.
    
-   **Hacer pruebas mÃ¡s fÃ¡cilmente**, porque cada funciÃ³n se puede probar por separado.

---

## ğŸŒŸ Â¿QuÃ© pasa si no usamos funciones?

EstÃ¡s trabajando con secuencias de ADN y necesitas calcular el contenido GC de **varias secuencias** obtenidas de diferentes genes.



``` python
seq1 = "ATGCGCGTAAAGC"
gc1 = (seq1.count('G') + seq1.count('C')) / len(seq1) * 100

seq2 = "TTATGGCCATAT"
gc2 = (seq2.count('G') + seq2.count('C')) / len(seq2) * 100

seq3 = "GGCCGCGCGCGG"
gc3 = (seq3.count('G') + seq3.count('C')) / len(seq3) * 100

print(gc1, gc2, gc3)
```

ğŸ§¨ Este cÃ³digo:

.tiny[
- Repite la misma lÃ³gica varias veces.
- Es difÃ­cil de modificar (imagina que ahora quieres redondear o validar...).
- Es propenso a errores si cambias una lÃ­nea pero no las demÃ¡s.
]

---

## âœ… Con funciÃ³n:


``` python
def contenido_gc(seq):
    return (seq.count('G') + seq.count('C')) / len(seq) * 100

secuencias = [
    "ATGCGCGTAAAGC",
    "TTATGGCCATAT",
    "GGCCGCGCGCGG"
]

for i, seq in enumerate(secuencias, start=1):
    print(f"Secuencia {i} â†’ GC%: {contenido_gc(seq):.2f}")
```

ğŸ§  Ventajas claras:

-   ReutilizaciÃ³n del cÃ³digo.
-   Mejor lectura.
-   MÃ¡s fÃ¡cil de **modificar o mejorar** (por ejemplo, agregar validaciÃ³n).
-   Lista para usar en otros proyectos o pruebas.

---

### ğŸ“ LecciÃ³n

&gt; "Con funciones, puedes resolver un problema **una sola vez** y usar esa soluciÃ³n tantas veces como necesites. AsÃ­ piensan los programadores profesionales: resolver inteligentemente, no repetir."


---

# ğŸ§© Sintaxis de una funciÃ³n

```python
def nombre_de_funcion(parÃ¡metros):
    # bloque de cÃ³digo
    return valor
```

ğŸ§± Partes de una funciÃ³n

.tiny[
1.  **`def`**  
    Palabra clave para **definir una funciÃ³n**.
    
2.  **Nombre de la funciÃ³n**  
    Debe ser **descriptivo** (por ejemplo: `calcular_promedio`, `limpiar_secuencia`), siguiendo la convenciÃ³n `snake_case`.
    
3.  **ParÃ©ntesis `()`**  
    Dentro van los **parÃ¡metros de entrada**, que son opcionales si no se necesitan.
    
4.  **Dos puntos `:`**  
    Indica el comienzo del **bloque de cÃ³digo** que pertenece a la funciÃ³n.
    
5.  **Bloque de cÃ³digo**  
    Todas las lÃ­neas dentro deben estar **indentadas** con 4 espacios (PEP8).
    
6.  **Sentencia `return` (opcional)**  
    Especifica el **valor que devuelve** la funciÃ³n. Si no se indica `return`, la funciÃ³n devuelve `None` por defecto.
]

---
# âœï¸ Ejemplo bÃ¡sico :Saludo

Una funciÃ³n puede definirse **sin parÃ¡metros** y **sin valor de retorno**. Solo ejecuta una acciÃ³n cuando es llamada.


``` python
# Definimos una funciÃ³n sin parÃ¡metros ni retorno
def di_hola():
    print("Â¡Hola!")

# Llamamos a la funciÃ³n: imprime el mensaje en la consola
di_hola()
```

--

.tiny[

### ğŸ“Œ ExplicaciÃ³n:

-   `def di_hola():` â†’ define una funciÃ³n llamada `di_hola`, que **no recibe datos**.
-   Dentro, ejecuta `print("Â¡Hola!")`.
-   Al llamar `di_hola()`, se imprime el mensaje.
-   **No hay `return`**, asÃ­ que el valor devuelto es `None` (implÃ­citamente).
]

---
## âœ FunciÃ³n con un parÃ¡metro

Una funciÃ³n puede recibir **informaciÃ³n de entrada** (llamada _parÃ¡metro_) y usarla para personalizar su comportamiento.


``` python
# Definimos una funciÃ³n que recibe un nombre como parÃ¡metro
def saludar_con_nombre(nombre):
    print(f"Â¡Hola, {nombre}!")

# Llamamos a la funciÃ³n pasando un argumento (una cadena)
saludar_con_nombre("AnaSofi")
```

---
## âœ FunciÃ³n con mÃºltiples parÃ¡metros y valor de retorno

Una funciÃ³n puede aceptar **mÃ¡s de un parÃ¡metro** y retornar un valor, que luego puede usarse o imprimirse.


``` python
# Definimos una funciÃ³n que multiplica dos valores
def multiplica(valor1, valor2):
    return valor1 * valor2

# Llamamos a la funciÃ³n con dos argumentos
resultado = multiplica(2, 3)

# Imprimimos el resultado: 6
print(resultado)
```


.tiny[
ğŸ“Œ ExplicaciÃ³n:
-   `valor1` y `valor2` son **parÃ¡metros** definidos en la funciÃ³n.
-   `multiplica(2, 3)` pasa dos **argumentos**: `2` y `3`.
-   La funciÃ³n retorna el producto de esos valores con `return`.
]

---
## ğŸ§© Algunos conceptos clave

Cuando trabajamos con funciones, es importante diferenciar entre:

### ğŸ”¹ ParÃ¡metro

Es una **variable definida en la funciÃ³n**. Es como un espacio reservado que recibirÃ¡ el valor al momento de llamar la funciÃ³n.

### ğŸ”¹ Argumento

Es el **valor real** que se pasa a la funciÃ³n cuando la invocamos. Es el dato concreto que sustituye al parÃ¡metro.

---

# ğŸ“Œ Ejemplo


``` python
def multiplica(valor1, valor2):
    return valor1 * valor2
```

-   AquÃ­, `a` y `b` son **parÃ¡metros**.
-   Son variables **internas a la funciÃ³n** que se usarÃ¡n para multiplicar.


``` python
print(multiplica(4, 5))  # 20
```

-   AquÃ­, `4` y `5` son **argumentos**.
-   Son los **valores reales** que se pasan a la funciÃ³n.

---
## ğŸ§  Â¡Vamos a transformar este cÃ³digo en una funciÃ³n!

Tenemos este cÃ³digo para contar el contenido de `A` y `T` en una secuencia de ADN:


``` python
my_dna = "ACTGATCGATTACGTATAGTATTTGCTATCATACATATATATCGATGCGTTCAT"

length = len(my_dna)
a_count = my_dna.count('A')
t_count = my_dna.count('T')
at_content = (a_count + t_count) / length

print("AT content is " + str(at_content))
```


.tiny[
Antes de convertirlo en funciÃ³n, piensa en:

-   ğŸ”¹ Â¿CuÃ¡l es la **entrada**?
    
-   ğŸ”¹ Â¿CuÃ¡l es la **salida**?
    
-   ğŸ”¹ Â¿QuÃ© parte del cÃ³digo se **puede generalizar o reutilizar**?

]

---
### ğŸ¤” Preguntas para realzar la transformaciÃ³n:

1.  âœ… Â¿QuÃ© dato deberÃ­a poder cambiar sin reescribir el cÃ³digo?
    
    -   ğŸ‘‰ **Â¿Y si quiero calcular el contenido AT de otra secuencia?**
        
2.  âœ… Â¿QuÃ© parte se repite si quiero hacer esto muchas veces?
    
    -   ğŸ‘‰ **Â¿Y si quiero analizar 10 secuencias diferentes?**
        
3.  âœ… Â¿QuÃ© parte es fija y quÃ© parte podrÃ­a ir como parÃ¡metro?
    
    -   ğŸ‘‰ **Â¿QuÃ© cambiarÃ­as si quisieras usar este cÃ³digo como parte de un anÃ¡lisis mÃ¡s grande?**

---

### âœ… Posible soluciÃ³n (la funciÃ³n): 

- Funcion: contenido_at

---

---


``` python
def contenido_at(secuencia):
    #Calcula el contenido AT de una secuencia de ADN.
    
    secuencia = secuencia.tupper()
    length = len(secuencia)
    a_count = secuencia.count('A')
    t_count = secuencia.count('T')
    return (a_count + t_count) / length
  

#resultado = contenido_at("ACTGATCGATTACGTATAGTATTTGCTATCATACATATATATCGATGCGTTCAT")
#print(f"AT content: {resultado:.2f}")
```

Quita los 2 Ãºltimos comentarios ... Â¿quÃ© ocurre?

---

### ğŸ’¡ Nota importante

.content-box-green[

&gt; Python **no ejecuta el cÃ³digo dentro de una funciÃ³n** cuando esta se define.  
&gt; Solo lo **interpreta y lo guarda en memoria** con su nombre.

&gt; Por eso, si hay un error dentro del bloque de la funciÃ³n, **no se mostrarÃ¡** al definirla â€” el error solo aparecerÃ¡ cuando realmente **llames (ejecutes)** la funciÃ³n.

]

---


``` python
def contenido_at(secuencia):
    # Calcula el contenido AT de una secuencia de ADN.
    
    secuencia = secuencia.upper()   # Â¡Â¡corregido!!
    length = len(secuencia)
    a_count = secuencia.count('A')
    t_count = secuencia.count('T')
    return (a_count + t_count) / length
  

resultado = contenido_at("ACTGATCGATTACGTATAGTATTTGCTATCATACATATATATCGATGCGTTCAT")
print(f"AT content: {resultado:.2f}")
```

---

## ğŸ§  Ejercicio para transformar en funciÃ³n

Conteo de bases de una secuencia de ADN.


``` python
# Secuencia de ADN
dna = "ATGCTTCAGAAAGGTCTTACG"

# Contar bases
a = dna.count('A')
t = dna.count('T')
g = dna.count('G')
c = dna.count('C')

# Imprimir resultados
print("A:", a)
print("T:", t)
print("G:", g)
print("C:", c)
```

---

### â“ Preguntas para guiar la transformaciÃ³n

1.  ğŸ”¹ Â¿CuÃ¡l es la **entrada**?
    
    -   Â¿QuÃ© cambiarÃ­as si tuvieras otra secuencia?
        
2.  ğŸ”¹ Â¿CuÃ¡l es la **salida**?
    
    -   Â¿DeberÃ­a imprimir o devolver los conteos?
        
3.  ğŸ”¹ Â¿QuÃ© parte podrÃ­as **generalizar**?
    
4.  ğŸ”¹ Â¿QuÃ© pasa si necesitas usar este cÃ³digo 100 veces en diferentes secuencias?

---

### Respuesta


``` python
def contar_bases(dna):
    """
    Cuenta e imprime el nÃºmero de A, T, G y C en una secuencia de ADN.
    """
    dna = dna.upper()  # Asegura que todas las letras estÃ©n en mayÃºsculas

    a = dna.count('A')
    t = dna.count('T')
    g = dna.count('G')
    c = dna.count('C')

    print("A:", a)
    print("T:", t)
    print("G:", g)
    print("C:", c)


# Llamando a la funciÃ³n
dna = "ATGCTTCAGAAAGGTCTTACG"
contar_bases(dna)
```

---
## ğŸ” Â¿Imprimir o retornar?

### OpciÃ³n 1: retornar con `return` â†’ mÃ¡s flexible



``` python
def contar_bases(dna):
    ...
    return conteo
```

Usa `print()` solo al momento de mostrar resultados.

### OpciÃ³n 2: imprimir desde dentro de la funciÃ³n


``` python
def print_contar_bases(dna):
    ...
    print(conteo)
```

Ãštil para tareas simples, **pero limita** el uso posterior del valor (no se puede guardar, comparar, ni reutilizar).

---

## VersiÃ³n modificada

- No imprimir dentro de la funciÃ³n, sino regresar los conteos.

- QuÃ© tipo de variable usamos para guardar los valores?

---
## VersiÃ³n con diccionarios 


``` python
def contar_bases(dna):
    # Cuenta el nÃºmero de A, T, G y C en una secuencia de ADN.
    dna = dna.upper()
    conteo = {
        'A': dna.count('A'),
        'T': dna.count('T'),
        'G': dna.count('G'),
        'C': dna.count('C')
    }
    return conteo

# Llamada a la funciÃ³n
dna = "ATGCTTCAGAAAGGTCTTACG"
resultado = contar_bases(dna)

# Imprimir los resultados fuera de la funciÃ³n
for base, cantidad in resultado.items():
    print(f"{base}: {cantidad}")
```

---
## ğŸ§  **Ãmbito de las variables (Scope)**

### ğŸ”¹ Â¿QuÃ© es el _scope_ (Ã¡mbito) de una variable?

--

Cuando defines una variable en Python, **su Ã¡mbito determina en quÃ© parte del programa esa variable es accesible**.

-   Las variables **definidas dentro de una funciÃ³n** son **locales** a esa funciÃ³n.
    
-   Las variables **definidas fuera** de cualquier funciÃ³n son **globales**.
    

---
## Acceso a variables globales dentro de una funciÃ³n



``` python
a = 1
b = 10

def fn():
    print(a)      # Se refiere a la variable global 'a'
    b = 20        # Se crea una nueva variable local 'b'
    print(b)      # Imprime la 'b' local

fn()

print(b)          # Imprime la 'b' global, que NO cambiÃ³
```

âœ… Salida esperada:: 

---

## ğŸ”’ Regla general de bÃºsqueda de variables (LEGB)

Python busca una variable en este orden:

1.  **L**ocal â€“ dentro de la funciÃ³n actual
    
2.  **E**nclosing â€“ en funciones anidadas (si existen)
    
3.  **G**lobal â€“ en el script principal
    
4.  **B**uilt-in â€“ funciones internas de Python (`print`, `len`, etc.)


---
## âš ï¸ Error comÃºn: acceder a variables locales fuera de su Ã¡mbito



``` python
def get_at_content(dna): 
    length = len(dna)
    a_count = dna.count('A')
    return (a_count + dna.count('T')) / length

print(a_count)  # âŒ ERROR: a_count estÃ¡ definida solo dentro de la funciÃ³n
```



---
## ğŸ§ª Argumentos para personalizar el resultado

Podemos agregar **mÃ¡s argumentos** a nuestras funciones para que el usuario pueda **modificar el comportamiento** o la salida.

En este ejemplo, permitimos que quien use la funciÃ³n decida **cuÃ¡ntas cifras decimales** mostrar en el resultado del contenido AT:



``` python
def get_at_content(dna, sig_figs):
    # Calcula el contenido AT de una secuencia de ADN,
    # redondeando a 'sig_figs' cifras decimales.
    length = len(dna)
    a_count = dna.upper().count('A')
    t_count = dna.upper().count('T')
    at_content = (a_count + t_count) / length
    return round(at_content, sig_figs)  # usamos el argumento para redondear
  
  
test_dna = "ATGCATGCAACTGTAGC"

print(get_at_content(test_dna, 1))  # â†’ 0.5
print(get_at_content(test_dna, 2))  # â†’ 0.50
print(get_at_content(test_dna, 3))  # â†’ 0.500
```

---

### ğŸ§  ReflexiÃ³n para alumnos:

-   Â¿QuÃ© pasarÃ­a si no pasamos el segundo argumento?  
    (â†’ GenerarÃ¡ un error a menos que tenga un valor por defecto).
    
-   Â¿CÃ³mo podrÃ­as hacer que `sig_figs` sea **opcional**?

---

## ğŸ¯ Paso de argumentos

En Python, puedes **pasar argumentos** a una funciÃ³n de distintas formas:

### ğŸŸ¢ 1. Argumentos posicionales

Se pasan **en el orden en que se definen** los parÃ¡metros en la funciÃ³n.


``` python
# definicion
def get_at_content(dna, sig_figs):
    #....
    return round(at_content, sig_figs)

# llamado a la funciÃ³n    
get_at_content("ATCGTGACTCG", 2)
```

-   `"ATCGTGACTCG"` se asigna a **`dna`**
-   `2` se asigna a **`sig_figs`**

**Y si se te olvida el orden y los intercambias??**

---

### ğŸŸ¡ 2. Argumentos con nombre (keyword arguments)

Puedes especificar el **nombre del parÃ¡metro**, lo que hace que el **orden no importe**.


``` python
get_at_content(dna="ATCGTGACTCG", sig_figs=2)
get_at_content(sig_figs=2, dna="ATCGTGACTCG")
```

âœ”ï¸ Ambas llamadas hacen lo mismo.

---
### âš ï¸ Reglas importantes

-   Los **argumentos posicionales deben ir primero**.
    
-   DespuÃ©s se pueden poner los **argumentos con nombre**.
    

âŒ Este ejemplo es invÃ¡lido:


``` python
get_at_content(dna="ATCGTGACTCG", 2)  # âŒ ERROR
```

Llamadas vÃ¡lidas:


``` python
# Posicional + keyword â†’ âœ”ï¸ correcto
get_at_content("ATCGTGACTCG", sig_figs=3)

# Solo keyword arguments â†’ âœ”ï¸ correcto
get_at_content(dna="ATCGTGACTCG", sig_figs=2)

# Solo posicionales â†’ âœ”ï¸ correcto
get_at_content("ATCGTGACTCG", 2)
```

---
## ğŸ§© Definir parÃ¡metros con valores por defecto

Puedes definir un valor por defecto en la funciÃ³n para que **ese parÃ¡metro sea opcional**.


``` python
def get_at_content(dna, sig_figs=2):
    length = len(dna)
    a = dna.upper().count('A')
    t = dna.upper().count('T')
    at_content = (a + t) / length
    return round(at_content, sig_figs)

get_at_content("ATCGTGACTCG")               # Usa el valor por defecto (2)
get_at_content("ATCGTGACTCG", sig_figs=3)   # Usa 3 cifras significativas
```


#### âœ… Ventajas de usar parÃ¡metros por nombre o con valor por defecto

-   Mejora la **legibilidad** del cÃ³digo.
-   Permite **parÃ¡metros opcionales**.
-   Hace que las funciones sean mÃ¡s **versÃ¡tiles** y fÃ¡ciles de usar.


---

# ğŸ”„ ParÃ¡metros variables: *args y **kwargs

## ğŸ§  Â¿QuÃ© son `*args` y `**kwargs`?

Permiten que una funciÃ³n reciba **una cantidad variable de argumentos**, sin saber de antemano cuÃ¡ntos serÃ¡n.

---

## ğŸ”¹ `*args` â†’ argumentos posicionales variables

-   Usamos `*args` para recibir **cualquier nÃºmero de argumentos posicionales**.
-   Internamente, Python los guarda como una **tupla**.
    

### âœ… Ejemplo:


``` python
def suma(*numeros):
    return sum(numeros)

print(suma(1, 2))             # 3
print(suma(1, 2, 3, 4, 5))    # 15
```

---
## ğŸ”¸ `**kwargs` â†’ argumentos nombrados variables

-   Usamos `**kwargs` para recibir **cualquier nÃºmero de argumentos con nombre**.
-   Internamente, Python los guarda como un **diccionario**.
    

### âœ… Ejemplo:



``` python
def mostrar_info(**datos):
    for clave, valor in datos.items():
        print(f"{clave}: {valor}")

mostrar_info(nombre="Ana", edad=28, ciudad="CDMX")
```

---

## ğŸ’¡ Puedes combinarlos


``` python
def ejemplo_completo(a, b, *args, **kwargs):
    print(f"a = {a}, b = {b}")
    print("args:", args)
    print("kwargs:", kwargs)

ejemplo_completo(1, 2, 3, 4, 5, nombre="Ana", edad=30)
```


#### ğŸ“Œ Salida:

---

## ğŸ§  Reglas importantes

-  El orden siempre debe ser:
   

``` python
def funcion(fijos, *args, **kwargs):
```

-   Solo puede haber **uno** de cada uno en la definiciÃ³n.
    
-   `args` y `kwargs` son nombres convencionales, pero puedes usar otros:


``` python
def funcion(*valores, **opciones):
```

---

## âœ… Buenas prÃ¡cticas (PEP8 + PEP257)

| PrÃ¡ctica                     | Â¿Por quÃ©?                                               |
|-----------------------------|----------------------------------------------------------|
| **Nombre descriptivo**          | Facilita entender el propÃ³sito de la funciÃ³n            |
| **Una sola responsabilidad**    | Evita funciones confusas y difÃ­ciles de probar          |
| **Retornar, no imprimir**       | Permite reutilizar y testear los resultados             |
| **Valores por defecto**         | Mejora flexibilidad y facilidad de uso                  |
| Docstring                   | Documenta claramente quÃ© hace y cÃ³mo usarla             |
| Probar con `assert`         | Asegura que la funciÃ³n funciona como se espera          |
| Validar entradas            | Evita errores difÃ­ciles de detectar                     |
| Reutilizar en mÃ³dulos       | Mantiene el cÃ³digo organizado y limpio                  |

---

## ğŸ’¡ Â¿QuÃ© es un docstring?

Un **docstring** (_documentation string_) es un texto que se escribe justo despuÃ©s de la definiciÃ³n de una funciÃ³n (o clase/mÃ³dulo) para **describir quÃ© hace y cÃ³mo se usa**.

### âœï¸ Se escribe entre triple comillas (`""" """` o `''' '''`)

Se trata de una **documentaciÃ³n interna**, que:

-   Facilita la lectura del cÃ³digo por otras personas (o por ti mismo en el futuro).
    
-   Aparece cuando usas funciones como `help()` o herramientas como Jupyter o VSCode.
    
-   Es una **buena prÃ¡ctica obligatoria** en proyectos profesionales y acadÃ©micos.

---
## ğŸ§ª Ejemplo: get_at_content

VersiÃ³n con docstring


``` python
def get_at_content(dna, sig_figs=2):
    """
    Calcula el contenido AT de una secuencia de ADN,
    redondeando a un nÃºmero especÃ­fico de cifras decimales.

    ParÃ¡metros:
    dna (str): Secuencia de ADN (ej. 'ATGCGC')
    sig_figs (int, opcional): nÃºmero de cifras decimales (por defecto = 2)

    Retorna:
    float: contenido AT redondeado
    """
    dna = dna.upper()
    length = len(dna)
    a = dna.count('A')
    t = dna.count('T')
    at_content = (a + t) / length
    return round(at_content, sig_figs)
```

---

## â„¹ï¸ Â¿QuÃ© debe incluir un buen docstring?

1.  **Una lÃ­nea resumen clara**.
    
2.  (Opcional) Una descripciÃ³n mÃ¡s extensa si lo amerita.
    
3.  Lista de **parÃ¡metros** con sus tipos y significados.
    
4.  **Valor retornado** y su tipo.
    

âœ… Buenas prÃ¡cticas PEP257

- Usar comillas triples.
- Comenzar con una frase en modo afirmativo (â€œCalculaâ€¦â€, â€œDevuelveâ€¦â€).
- Describir argumentos, especialmente si hay mÃ¡s de uno.
- No olvidar incluir el tipo de dato esperado y retornado.
    
    
Ver https://www.datacamp.com/es/tutorial/docstrings-python 

---

## âœ… IntroducciÃ³n al **Testing** en Python

### ğŸ§  Â¿Por quÃ© probar nuestro cÃ³digo?

En programaciÃ³n, **cometer errores es inevitable**. Por eso, es fundamental incluir mecanismos que:

-   Detecten errores antes de que el programa se use en producciÃ³n.
    
-   Verifiquen que las funciones realmente hacen lo que dicen en su docstring.
    
-   Faciliten el mantenimiento al evitar que los cambios rompan funcionalidades anteriores.
    

&gt; âœ¨ El testing es como una red de seguridad para tu cÃ³digo.

---

## ğŸ§ª Â¿CÃ³mo hacemos testing en Python?

### âœ… Con la instrucciÃ³n `assert`


``` python
assert expresiÃ³n_booleana
```

-   Si la expresiÃ³n es `True`, **el programa sigue normalmente**.
-   Si es `False`, lanza un **`AssertionError`** que detiene el programa.


---
## ğŸ§¬ Ejemplo aplicado: funciÃ³n get_at_content



``` python
def get_at_content(dna, sig_figs=2):
    """
    Calcula el contenido AT de una secuencia de ADN.
    Retorna el resultado redondeado a 'sig_figs' cifras decimales.
    """
    dna = dna.upper()
    length = len(dna)
    a_count = dna.count('A')
    t_count = dna.count('T')
    at_content = (a_count + t_count) / length
    return round(at_content, sig_figs)
```

ğŸ§ª Testing bÃ¡sico con assert


``` python
assert get_at_content("ATGC", 1) == 0.5
assert get_at_content("ATGC", 1) == 0.4  # âŒ AssertionError
```

---
## âš ï¸ Testing tambiÃ©n revela problemas lÃ³gicos



``` python
assert get_at_content("ATGCNNNNNN", 1) == 0.5
```

âŒ Este test fallarÃ¡ si la funciÃ³n no descarta las N.

ğŸ’¡ SoluciÃ³n: limpiar la secuencia dentro de la funciÃ³n:


``` python
dna = dna.replace("N", "")
```

---
## ğŸ” Testing con mÃºltiples casos

Puedes validar diferentes entradas asÃ­:


``` python
assert get_at_content("A") == 1.0
assert get_at_content("G") == 0.0
assert get_at_content("ATGC") == 0.5
assert get_at_content("AGG", 1) == 0.3
assert get_at_content("AGG", 5) == 0.33333
```

âœ”ï¸ Cada lÃ­nea valida un caso distinto.

---
## ğŸ›¡ï¸ ValidaciÃ³n con `assert` dentro de la funciÃ³n

Puedes proteger la funciÃ³n de errores de uso con `assert`:


``` python
def get_at_content(dna, sig_figs=2):
    assert isinstance(dna, str), \
        f"dna debe ser string, no {type(dna)}"
    assert dna != "", "dna no puede ser una cadena vacÃ­a"
    assert sig_figs &gt;= 0, "sig_figs debe ser mayor o igual a cero"

    dna = dna.upper().replace("N", "")
    length = len(dna)
    a_count = dna.count('A')
    t_count = dna.count('T')
    return round((a_count + t_count) / length, sig_figs)
```

&gt; La funciÃ³n `isinstance(objeto, clase_tipo)` sirve para verificar si un objeto es de un tipo o clase especÃ­fica.

---

## âœ… Â¿Se deben dejar los `assert` en producciÃ³n?

### ğŸ§ª 1. **Durante el desarrollo**: Â¡SÃ­, Ãºsalos!

-   `assert` es perfecto para **testing interno**, validar suposiciones y detectar errores temprano.
    
-   Ayuda a encontrar fallos lÃ³gicos o mal uso de funciones.
    
-   No requiere librerÃ­as externas ni estructura formal de testing.
    
---

### ğŸš¨ 2. **En producciÃ³n (programas ya en uso)**: **âŒ No deberÃ­as confiar en `assert` para validaciones importantes**

#### Â¿Por quÃ©?

-   Los `assert` **pueden ser ignorados automÃ¡ticamente** si Python se ejecuta con el modo optimizado (`python -O programa.py`).
    
-   En ese modo, **todos los `assert` se eliminan al compilar**.


âœ… En producciÃ³n, usa validaciones explÃ­citas:

```
if not isinstance(dna, str):
    raise TypeError("dna debe ser una cadena de texto")

if sig_figs &lt; 0:
    raise ValueError("sig_figs debe ser mayor o igual a cero")
```

Esto nunca serÃ¡ ignorado y puedes manejarlo con try/except.

---

### âœ… Reglas prÃ¡cticas para usar `assert`

| Contexto           | Â¿Usar `assert`? | Â¿Por quÃ©?                                     |
|--------------------|-----------------|-----------------------------------------------|
| Desarrollo         | âœ… SÃ­           | Para validar suposiciones y detectar errores  |
| Scripts personales | âœ… SÃ­           | RÃ¡pido y cÃ³modo para testing                  |
| ProducciÃ³n         | âš ï¸ No           | Puede ser ignorado con `-O`; usa excepciones  |
| Testing formal     | âš ï¸ No           | Usa `unittest` o `pytest` en su lugar         |



---
## âœ… ConclusiÃ³n

&gt; Usa `assert` como herramienta **de desarrollo**, no como validaciÃ³n definitiva en producciÃ³n.

&gt; Mas adelante veremos otras formas de hacer Testing.

---
## ğŸ” CaracterÃ­sticas avanzadas de funciones en Python

| CaracterÃ­stica                        | DescripciÃ³n breve                                                                 | Ejemplo corto |
|--------------------------------------|-----------------------------------------------------------------------------------|---------------|
| Funciones anidadas                   | Definir funciones dentro de otras para encapsular lÃ³gica                         | `def externa(): def interna(): ...` |
| Closures                             | Funciones internas que recuerdan variables del entorno externo                   | `def outer(x): def inner(): return x` |
| Decoradores                          | AÃ±aden funcionalidad a otra funciÃ³n sin modificarla directamente                 | `@mi_decorador` |
| Funciones como objetos               | Se pueden pasar, retornar y asignar a variables                                  | `f = saludar` |
| Recursividad                         | FunciÃ³n que se llama a sÃ­ misma                                                  | `def factorial(n): return n * factorial(n-1)` |
---
## ğŸ” CaracterÃ­sticas avanzadas de funciones en Python

| CaracterÃ­stica                        | DescripciÃ³n breve                                                                 | Ejemplo corto |
|--------------------------------------|-----------------------------------------------------------------------------------|---------------|
| Funciones lambda                     | Funciones anÃ³nimas en una sola lÃ­nea                                             | `lambda x: x ** 2` |
| Funciones de orden superior          | Reciben funciones como argumentos o devuelven funciones                          | `map(lambda x: x+1, lista)` |
| Type hints                           | Anotan tipos de parÃ¡metros y retorno                                             | `def f(x: int) -&gt; int:` |
| Funciones generadoras (`yield`)     | Generan secuencias sin cargar todo en memoria                                    | `def gen(): yield 1` |


---

# ğŸ“š Recursos extra

- [PEP8](https://peps.python.org/pep-0008/)
- [DocumentaciÃ³n oficial de funciones](https://docs.python.org/es/3/tutorial/controlflow.html#defining-functions)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
