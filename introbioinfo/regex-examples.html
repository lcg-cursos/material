<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introducci√≥n a la Bioinform√°tica</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introducci√≥n a la Bioinform√°tica
]
.institute[
### Licenciatura en Ciencias Gen√≥micas,UNAM
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;

# ¬øQu√© aprender√°s hoy?

- C√≥mo usar expresiones regulares (regex) en bioinform√°tica
- Detectar patrones como codones, sitios de restricci√≥n y regiones repetidas
- Probar tus expresiones en [regex101.com](https://regex101.com)

---
## üñ•Ô∏è Introducci√≥n a regex101.com

[regex101.com](https://regex101.com/) es una herramienta interactiva para **escribir, probar y depurar expresiones regulares** en distintos lenguajes.

### üîç Secciones principales de la interfaz

1. **Regular Expression** (parte superior central):
   - Aqu√≠ escribes tu patr√≥n de b√∫squeda.
   - Se activa la opci√≥n `/gm` (global y multiline) por defecto.

2. **Test String** (panel grande abajo):
   - Zona donde escribes tu texto de prueba, como secuencias de ADN o l√≠neas de archivo.
   - Puedes usar varias l√≠neas para simular archivos FASTA, GFF, etc.

3. **Explanation** (panel derecho superior):
   - Muestra una explicaci√≥n autom√°tica de tu regex en tiempo real.

---
## üñ•Ô∏è Introducci√≥n a regex101.com

4. **Match Information** (derecha inferior):
   - Indica qu√© partes coinciden, cu√°ntas veces y en qu√© posiciones.

5. **Flavor (izquierda)**:
   - Selecciona el lenguaje de destino (sugerimos **PCRE2** o **Python**).

6. **Quick Reference** (abajo a la derecha):
   - Tabla √∫til con todos los **metacaracteres**, sus funciones y ejemplos (`^`, `$`, `\b`, `\w`, etc).

7. **Substitution / Unit Tests / List** (opcional):
   - Funciones avanzadas para sustituir texto o probar m√∫ltiples entradas.


---

# Archivo base de secuencias üî¨

Estas secuencias se usar√°n en varios ejercicios del curso, aqui las numeramos porque en el texto haremos referencia al n√∫mero para facilitar su referencia:

```text
1. ATGCGTAC
2. AATTGGCCAATTGGCC
3. GCTAGCTGATCGATC
4. ATGATGATG
5. AAAAAA
6. CGTATGCGTAGCTAGCGT
7. AGCTTCTGAAGCT
8. TGACCTGAAGCTTAGC
9. ATCGTACGTAGCTACGATCG
10. GATCGATCGATCGATCGATC
11. GAGAGA
12. ATATAT
13. gene1    100    ATGCGT
14. atgtaa
15. &gt;seq1 description of sequence
```

---

## Preparandonos para la pr√°ctica

Pega este texto en TEST STRING en https://regex101.com/

```text
ATGCGTAC
ATGATGATGAAATA
AATTGGCCAATTGGCC
GCTAGCTGATCGATC
ATGATGATG
AAAAAA
CGTATGCGTAGCTAGCGT
AGCTTCTGAAGCT
TGACCTGAAGCTTAGC
ATCGTACGTAGCTACGATCG
GATCGATCGATCGATCGATC
GAGAGA
ATATAT
gene1    100    ATGCGT
atgtaa
&gt;seq1 description of sequence
```

---

## Metacaracteres de RegEx

Vamos a revisar en esta clase:

1. **Caracteres literales**
2. `.` punto
3. `*`, `+`, `?`, `{m,n}` (cuantificadores)
4. `^` y `$` (anclas de inicio/fin)
5. `[ ]` y `[^ ]` (clases y negaciones)
6. `|` (alternancia l√≥gica)
7. `( ... )` (agrupamiento)
8. `\1` (retroreferencia)
9. `(?=X)` (lookahead)
10. `(?&lt;=X)` (lookbehind)
11. `(?i)` (modificador: case-insensitive)
12. `\w`, `\b`, `\t` (palabras, l√≠mites, tabulador)
13. **Integraci√≥n final**: ORF completo con codones de inicio y parada

---

# Ejemplo 1: Caracteres literales

Buscar exactamente `ATG`

```regex
ATG
```

‚úÖ Coincide en: `ATGCGTAC`


‚ùì Intenta:  

- Buscar `GCC`
- Ver si coincide `TTT`

---

# Ejemplo 2: Punto `.`

Cualquier letra entre A y G

```regex
A.G
```

‚úÖ Coincide en: `ATG` de `ATGCGTAC`


‚ùì Intenta:

- `G.T` ¬øcoincide?
- `A..T` ¬øfunciona?

---

# Ejemplo 3: Cuantificadores `+`, `*`, `{}`

Los cuantificadores nos dicen **cu√°ntas veces debe repetirse un patr√≥n** para que haya coincidencia.

### üîπ `+` ‚Äî Uno o m√°s.  
Coincide con **al menos una** repetici√≥n del car√°cter o grupo.

- `A+` ‚Üí una o m√°s A seguidas.

**Ejemplos en las secuencias:**

- `A+` ‚Üí coincide en: `AAAAAA` (sec. 5)

---
# Ejemplo 3: Cuantificadores `+`, `*`, `{}`

#### üî∏ `*` ‚Äî Cero o m√°s
Coincide con **cero o m√°s** repeticiones (es decir, incluso si no aparece).

- `T*G` ‚Üí cualquier n√∫mero de T seguidas de una G.

**Ejemplos en las secuencias:**
- `T*G` ‚Üí coincide en: `ATGCGTAC` (sec. 1)

---
# Ejemplo 3: Cuantificadores `+`, `*`, `{}`

#### üîπ `{n}` ‚Äî Exactamente n repeticiones
- `A{3}` ‚Üí exactamente tres A seguidas.

#### üî∏ `{n,}` ‚Äî Al menos n repeticiones
- `G{2,}` ‚Üí dos o m√°s G seguidas.

#### üî∏ `{n,m}` ‚Äî Entre n y m repeticiones
- `C{2,4}` ‚Üí entre dos y cuatro C.

**Ejemplos en las secuencias:**
- `A{3}` ‚Üí coincide en: `AAAAAA` (sec. 5)
- `G{2,}` ‚Üí coincide en: `AATTGGCCAATTGGCC` (sec. 2)

---

# Ejemplo 4: Anclas ^ y $

Solo si est√° al principio.

```regex
^ATG
```

‚úÖ Coincide en: `ATGCGTAC`

‚ùì Intenta:

- Buscar `^GAT`
- Probar `^TGA` en medio

---
# Ejemplo 4: Anclas ^ y $

Solo si est√° **al final** de la secuencia.

```regex
TGA$
```

‚úÖ Coincide en: `ATGCGTACTGA`   
‚ùå No coincide en: `GGCATCTAGGAC`

‚ùì Intenta:

-   Modificar una secuencia que termine en `TAA` o `TAG`.  
-   ¬øQu√© pasa si pones `$` al inicio por error?
    

**Recuerda:**.  
-   `^` significa "empieza con..."
-   `$` significa "termina con..."


---

## Ejemplo 5: Clases `[ ]` y negaciones `[^ ]`

Una **clase de caracteres** permite definir un **conjunto de letras o s√≠mbolos v√°lidos** para una posici√≥n en la secuencia. 

- Los corchetes [ ] indican que **una sola posici√≥n** puede coincidir con **varias opciones**.
- El s√≠mbolo `^` dentro del grupo **niega** (excepto).

Ejemplo: G precedida de A o T.

```regex
[AT]G
```

‚úÖ Coincide en: `ATG` y `TGA`

‚ùì Intenta:   

- `[CT]C`
- `[^AG]T`

---

# Ejemplo 6: Alternancia `|`

Coincide con ATG o GTG.

```regex
ATG|GTG
```

‚úÖ Coincide en: `ATGATGATG`


‚ùì Intenta:  
- `TAG|TAA`
- `CTG|AAC`

---

# Ejemplo 7: Agrupamiento `(...)`

Un **grupo** se define entre par√©ntesis `()` y sirve para:

1. **Agrupar varios caracteres como una sola unidad.**
2. Aplicar **cuantificadores** al grupo completo.
3. Capturar lo que coincide, para usarlo despu√©s (como en retroreferencias).


Por ejemplo: Uno o m√°s repeticiones del grupo.

```regex
(ATG)+
```

‚úÖ Coincide en: `ATGATG`

‚ùì Intenta:   
- `(GC)+`
- `(TA)+`

---

# Ejemplo 8: Retroreferencia `\1`

Una **retroreferencia** te permite **volver a usar un grupo que ya hiciste coincidir antes** en la misma expresi√≥n.

Cuando usas par√©ntesis `( )` en una regex, est√°s **capturando** lo que coincidi√≥.

Luego puedes referirte a ese grupo con:

- `\1` para el **primer grupo**
- `\2` para el segundo, y as√≠ sucesivamente

Ejemplo: Busca repeticiones exactas.

```regex
(GA)\1
```

‚úÖ Coincide en: `GAGAGA`

‚ùì Intenta:    

- `(AT)\1`
- `(CG)\1`

---

# Ejemplo 9: Lookahead `(?=X)`

Un **lookahead** se escribe as√≠: `X(?=Y)`

Significa: **"Encuentra X solo si est√° seguido por Y"**, pero **sin incluir Y** en la coincidencia.

Ejemplo: A que venga antes de T.

```regex
A(?=T)
```

‚úÖ Coincide en: `AGCTTCTGAAGCT`

‚ùì Intenta:

- `G(?=C)`
- `T(?=A)`

---

# Ejemplo 10: Lookbehind `(?&lt;=X)`

Un **lookbehind** se escribe as√≠: `(?&lt;=Y)X`

Significa: **"Encuentra X solo si est√° precedido por Y"**, pero **sin incluir Y** en la coincidencia.


Por ejemplo: A precedido por G.


```regex
(?&lt;=G)A
```

‚úÖ Coincide en: `TGACCTGAAGCTTAGC`

‚ùì Intenta:   
- `(?&lt;=T)C`
- `(?&lt;=C)T`

---

# Modificadores `(?i)`

Los **modificadores** permiten alterar c√≥mo funciona una expresi√≥n regular. Se escriben al inicio con `(?...)`, o se activan con casillas en regex101.

### üîß Modificadores m√°s comunes:

| Modificador | Qu√© hace                      | Ejemplo                   |
|-------------|-------------------------------|---------------------------|
| `(?i)`      | Ignora may√∫sculas/min√∫sculas  | `(?i)atg` ‚Üí ATG o atg     |
| `(?m)`      | Modo multil√≠nea (`^` y `$`)    | `^&gt;` en FASTA multilinea  |
| `(?s)`      | `.` tambi√©n incluye saltos de l√≠nea | √∫til con secuencias largas |
| `(?x)`      | Ignora espacios en la regex y permite comentarios (modo extendido) | para expresiones legibles |

---

**üß† ¬øD√≥nde se usan?**

- (?i) es √∫til cuando no sabes si el texto est√° en may√∫sculas o min√∫sculas.
- (?m) se usa para analizar archivos con varias l√≠neas como .fasta.
- (?s) permite que . incluya saltos de l√≠nea (por defecto no lo hace).


**‚úÖ En regex101:**

Puedes activarlos con las casillas:

- i (insensitive)
- m (multiline)
- s (dotall)

---

# Ejemplo 11: Modificadores `(?i)`

Ignora may√∫sculas/min√∫sculas.

```regex
(?i)atg
```


‚úÖ Coincide en: `atgtaa`, `ATGCGTAC`

‚ùì Intenta:  
- `(?i)taa`
- `atg` sin `(?i)`

---

# Ejemplo 12: Palabras y tabuladores

`ATG` como palabra aislada.

```regex
\bATG\b
```

‚úÖ Coincide en: `gene1    100    ATGCGT`

‚ùì Intenta:    
- `\w{4}`
- `\bTGA\b`

---

# Ejemplo 13: ORF completo

Un marco abierto de lectura completo.

```regex
^ATG[ATGC]{3,}(TAA|TAG|TGA)$
```

‚úÖ Coincide en: `ATGCGTAGCTAA`

‚ùì Intenta:   
- Uno sin cod√≥n de parada

---

---

# Probemos las regex con `grep`

```bash
grep 'REGEX' secuencias.txt
```

Para que los metacaracteres funcionen correctamente, debes usar comillas simples `' '`.

Tambi√©n puedes a√±adir:

-   `-E` para usar **extended regex**.  
-   `-i` para **ignorar may√∫sculas**.  
-   `-n` para ver el **n√∫mero de l√≠nea**

---
##  Las regex y la familia de `grep`

Cuando hablamos de expresiones regulares en la terminal, no todas funcionan igual. Dependiendo de la herramienta o la opci√≥n que uses (`grep`, `egrep`, `grep -P`...), est√°s usando una **versi√≥n diferente** del "lenguaje regex".


---

## üß© Tipos de expresiones regulares

### 1. üîπ BRE ‚Äì Basic Regular Expressions
- Usado por defecto en `grep`.
- Los metacaracteres permitidos: . ^ $ * [ ] [^ ]  
- Metacaracteres como `+`, `?`, `|`, `()` **no tienen efecto especial** a menos que se escapen con `\`.
- Ejemplo:

  ```bash
  grep 'A\{3\}' secuencias.txt
  ```

---

### 2. üî∏ ERE ‚Äì Extended Regular Expressions

- Se activa con `grep -E` o usando `egrep`.
- **Permite usar directamente** los b√°sicos: . ^ $ * [ ] [^ ]  
      `+`, `?`, `|`, `()`, `{}` 

Ejemplos:

```bash
grep -E 'A{3}' secuencias.txt
grep -E '(ATG)+' secuencias.txt
```

---

### 3. üîÆ PCRE ‚Äì Perl-Compatible Regular Expressions

- Se activa con `grep -P` (si est√° disponible en tu sistema).
- Soporta muchas funciones avanzadas:   
  - `\b`, `\s`, `\t`
  - Lookahead `(?=...)`
  - Lookbehind `(?&lt;=...)`
  - Retroreferencias `\1`, `\2`, ...
- Ejemplos:

```bash
grep -P '(?&lt;=G)A' secuencias.txt
grep -P '\bATG\b' secuencias.txt
grep -P '(GA)\1' secuencias.txt
```

---

## üìä Comparaci√≥n r√°pida

| Elemento             | BRE (`grep`) | ERE (`grep -E`) | PCRE (`grep -P`) |
|----------------------|--------------|------------------|------------------|
| . ^ $ * [ ] [^ ]     |  ‚úÖ          |  ‚úÖ               | ‚úÖ               |   
| `+`, `?`, Alternativas, `()`  | ‚ùå (usa `\`) |  ‚úÖ (directo)     | ‚úÖ (directo)     |
| `\b`, `\s`, `\t`     | ‚ùå           | ‚ùå                | ‚úÖ               |
| Lookahead/lookbehind | ‚ùå           | ‚ùå                | ‚úÖ               |
| Retroreferencias     | ‚ùå           | ‚ùå                | ‚úÖ               |
| Legibilidad/Potencia | üî∏ B√°sica    | üîπ Media         | üîÆ Avanzada      |

---

## üß™ Recomendaci√≥n pr√°ctica

| Si quieres...                                  | Usa...        |
|------------------------------------------------|---------------|
| Coincidencias simples o archivos planos        | `grep` (BRE)  |
| Cuantificadores o agrupaciones complejas       | `grep -E`     |
| Potencia total para bioinform√°tica avanzada    | `grep -P`     |

---

# Pr√°ctica

Vamos a resolver los ejercicios con grep, para ello necesitamos:

1. Crear un directorio llamado `regex` en intro-bioinfo.   
2. generar un archivo llamado `secuencias.txt` y pega las secuencias que usaste en la practica anterior con regex101.

---

## Resolviendo los ejemplos con `grep` 

1. Buscar exactamente la subcadena `ATG`

```bash
grep 'ATG' secuencias.txt
```

2. **Buscar una letra A seguida de cualquier car√°cter y luego una G.**

```bash
grep -E 'A.G' secuencias.txt
```

3. **Buscar una o m√°s letras A seguidas.**

```bash
grep -E 'A+' secuencias.txt
```
---
## Ejemplos 

**Buscar cero o m√°s T seguidas de una G.**
```bash
grep -E 'T*G' secuencias.txt
```

**Buscar exactamente tres A consecutivas.**
```bash
grep -E 'A{3}' secuencias.txt
```

---
## Ejemplos 

4. Anclas

**Buscar secuencias que comienzan con `ATG`.**

```bash
grep '^ATG' secuencias.txt
```

**Buscar secuencias que terminan con `TGA`.**

```bash
grep 'TGA$' secuencias.txt
```

---

## 5. Clases `[ ]` y negaciones `[^ ]`

**Buscar una G precedida por A o T.**

```bash
grep -E '[AT]G' secuencias.txt
```

**Buscar una T precedida por algo que NO sea A ni G.**

```bash
grep -E '[^AG]T' secuencias.txt
```

---

## 6. Alternancia `|`

**Buscar secuencias que contengan `ATG` o `GTG`.**

```bash
grep -E 'ATG|GTG' secuencias.txt
```

---

## 7. Agrupamiento `( ... )`

**Buscar una o m√°s repeticiones del motivo `ATG`.**

```bash
grep -E '(ATG)+' secuencias.txt
```

Ejemplo con mas de un grupo:

```bash
grep -E '(ATG)+.*(TA)+' secuencias.txt
```

---

## 8. Retroreferencia `\1`

**Buscar una repetici√≥n exacta del grupo `GA`.**

```bash
grep -P '(GA)\1' secuencias.txt

# alternativa con el lenguaje perl ( m√°s avanzado)
perl -ne 'print if /(GA)\1/' secuencias.txt
```

---
## 8. Retroreferencia `\1`

Ejemplo para cualquier repeticion 

```bash
grep -P 'T(..)\1' secuencias.txt 

grep -P '(...).{1,4}\1' secuencias.txt 
```

Retroreferencia para invertidos

```bash
grep -E '(ATG)+.*(TA)+\2\1' secuencias.txt
```

¬øQu√© matches habr√≠a?

---

## 9. Lookahead `(?=...)`

**Buscar una A que est√© seguida de una T.**

```bash
grep -P 'A(?=T)' secuencias.txt

# alternativa con el lenguaje perl ( m√°s avanzado)
perl -ne 'print if /A(?=T)/' secuencias.txt
```

---

## 10. Lookbehind `(?&lt;=...)`

**Buscar una A que est√© precedida por una G.**

```bash

grep -P '(?&lt;=G)A' secuencias.txt
grep -P '(?&lt;=G{1,3})A' secuencias.txt  # ‚ùå Error: lookbehind no fijo

# alternativa con el lenguaje perl ( m√°s avanzado)
perl -ne 'print if /(?&lt;=G)A/' secuencias.txt
```


---

## 10. Lookbehind `(?&lt;=...)`

M√°s de un caracter(fijos) a evaluar

```bash
grep -P '(?&lt;=TG)A' secuencias.txt 
grep -P '(?&lt;=CTG)A' secuencias.txt 

# error -- no fijo
grep -P '(?&lt;=G{1,2})A' secuencias.txt 
```

---

## 11. Modificadores `(?i)`

**Buscar `ATG` sin importar may√∫sculas o min√∫sculas.**

```bash
grep -i 'atg' secuencias.txt
```


---

## 12. Palabras y tabuladores

`\b` es un **metacaracter de ‚Äúl√≠mite de palabra‚Äù** ( NO representa un caracter) 
Marca la frontera **entre un car√°cter de palabra** (`\w`: letras, n√∫meros, guion bajo) **y uno que no lo es** (`\W`: espacios, signos, etc.).


**Buscar la palabra aislada `ATG`.**

```bash
grep -P '\bATG\b' secuencias.txt
```

### Tabuladores

**Buscar l√≠neas que contengan tabuladores.**

```bash
grep -P '\t' secuencias.txt
```

---

## 13. ORF completo

**Buscar un marco abierto de lectura que empiece en ATG, tenga un m√≠nimo de codones y termine con TAA, TAG o TGA.**

```bash
grep -E '^ATG[ATGC]{3,}(TAA|TAG|TGA)$' secuencias.txt
```


---

# Ejercicios de aplicaci√≥n en biolog√≠a real üß¨

En esta secci√≥n aplicaras expresiones regulares para identificar motivos biol√≥gicos comunes. Cada ejercicio incluye:

- Una **descripci√≥n del motivo**.
- Una **secuencia ejemplo**.
- Vamos a encontrar una **regex sugerida**.
- Lo que se espera **encontrar en la secuencia** si la expresi√≥n funciona correctamente.

Puedes trabajar individual o en equipo de 2 y resuelve los ejercicios.

---

# Caja TATA (promotor eucariota)

**¬øQu√© buscamos?**
Una **caja TATA** es una secuencia promotora rica en T y A que marca el inicio de transcripci√≥n en genes eucariotas. Su forma can√≥nica es `TATAAA`, pero puede variar ligeramente.

**Se espera encontrar:** una subcadena como `TATAAA`, `TATATA`, `TATATT`, etc.

```text
ACGTATATAAAGCT
```

Regex:

```regex

```

---

# Codones de inicio

**¬øQu√© buscamos?**
Codones como `ATG`, `GTG` o `TTG`, que pueden servir como **inicio de traducci√≥n** en distintos contextos gen√©ticos.

**Se esperan:** coincidencias exactas con uno de esos tres codones, al inicio de un ORF o dentro de un marco de lectura.

Secuencias ejemplo:

```text
GCCATGCGTACTG
TTGGTCGTGACC
AAGTTGGGCTTGATC
```

Regex:

```regex

```

---

# Codones de parada

**¬øQu√© buscamos?**
Los codones `TAA`, `TAG` y `TGA` indican el **fin de un marco de lectura** (ORF). Suelen encontrarse despu√©s de una regi√≥n codificante.

**Se espera encontrar:** cada vez que uno de estos codones aparece en la secuencia al final de un ORF.

Secuencia ejemplo 1:
```text
ATGCGTACCTAA
GGCATCTAGGAC
AAGGGTGACTGAATC
```

Regex:

```regex

```

---

# Regi√≥n GC rica

**¬øQu√© buscamos?**
Zonas con muchas **guaninas (G)** y **citosinas (C)** juntas, comunes en promotores bacterianos o regiones reguladoras.

**Se espera encontrar:** secuencias como `GGCC`, `GGGCCC`.

Secuencia ejemplo:

```text
GGCCATGGGCCT
```

Regex:
```regex

```

---

# Microsat√©lites (repeticiones CA)

**¬øQu√© buscamos?**
Repeticiones de **CA** como motivo **microsat√©lite**, √∫tiles en estudios poblacionales y gen√≥micos.

**Se espera encontrar:** al menos 5 repeticiones consecutivas de `CA`.


```text
CACACACACACAATG
```

Regex:
```regex

```

---

# Sitio de splicing (intrones eucariotas)

**¬øQu√© buscamos?**
Los intrones eucariotas t√≠picamente inician con `GT` y terminan con `AG`, separados por una secuencia variable.

**Se espera encontrar:** patrones que comiencen con `GT`, tengan entre 3 y 100 nucle√≥tidos, y terminen en `AG`.


```text
GTACGTAGCTAG
```

Regex:
```regex

```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
