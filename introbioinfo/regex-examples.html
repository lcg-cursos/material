<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introducci√≥n a la Bioinform√°tica</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introducci√≥n a la Bioinform√°tica
]
.institute[
### Licenciatura en Ciencias Gen√≥micas,UNAM
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;

# ¬øQu√© aprender√°s hoy?

- C√≥mo usar expresiones regulares (regex) en bioinform√°tica
- Detectar patrones como codones, sitios de restricci√≥n y regiones repetidas
- Probar tus expresiones en [regex101.com](https://regex101.com)

---
## üñ•Ô∏è Introducci√≥n a regex101.com

[regex101.com](https://regex101.com/) es una herramienta interactiva para **escribir, probar y depurar expresiones regulares** en distintos lenguajes.

### üîç Secciones principales de la interfaz

1. **Regular Expression** (parte superior central):
   - Aqu√≠ escribes tu patr√≥n de b√∫squeda.
   - Se activa la opci√≥n `/gm` (global y multiline) por defecto.

2. **Test String** (panel grande abajo):
   - Zona donde escribes tu texto de prueba, como secuencias de ADN o l√≠neas de archivo.
   - Puedes usar varias l√≠neas para simular archivos FASTA, GFF, etc.

3. **Explanation** (panel derecho superior):
   - Muestra una explicaci√≥n autom√°tica de tu regex en tiempo real.

---
## üñ•Ô∏è Introducci√≥n a regex101.com

4. **Match Information** (derecha inferior):
   - Indica qu√© partes coinciden, cu√°ntas veces y en qu√© posiciones.

5. **Flavor (izquierda)**:
   - Selecciona el lenguaje de destino (sugerimos **PCRE2** o **Python**).

6. **Quick Reference** (abajo a la derecha):
   - Tabla √∫til con todos los **metacaracteres**, sus funciones y ejemplos (`^`, `$`, `\b`, `\w`, etc).

7. **Substitution / Unit Tests / List** (opcional):
   - Funciones avanzadas para sustituir texto o probar m√∫ltiples entradas.


---

# Archivo base de secuencias üî¨

Estas secuencias se usar√°n en varios ejercicios del curso, aqui las numeramos porque en el texto haremos referencia al n√∫mero para facilitar su referencia:

```text
1. ATGCGTAC
2. AATTGGCCAATTGGCC
3. GCTAGCTGATCGATC
4. ATGATGATG
5. AAAAAA
6. CGTATGCGTAGCTAGCGT
7. AGCTTCTGAAGCT
8. TGACCTGAAGCTTAGC
9. ATCGTACGTAGCTACGATCG
10. GATCGATCGATCGATCGATC
11. GAGAGA
12. ATATAT
13. gene1    100    ATGCGT
14. atgtaa
15. &gt;seq1 description of sequence
```

---

## 

Pega este texto en TEST STRING

```text
ATGCGTAC
AATTGGCCAATTGGCC
GCTAGCTGATCGATC
ATGATGATG
AAAAAA
CGTATGCGTAGCTAGCGT
AGCTTCTGAAGCT
TGACCTGAAGCTTAGC
ATCGTACGTAGCTACGATCG
GATCGATCGATCGATCGATC
GAGAGA
ATATAT
gene1    100    ATGCGT
atgtaa
&gt;seq1 description of sequence
```

---

## Metacaracteres de RegEx

Vamos a revisar en esta clase:

1. **Caracteres literales**
2. `.` punto
3. `*`, `+`, `?`, `{m,n}` (cuantificadores)
4. `^` y `$` (anclas de inicio/fin)
5. `[ ]` y `[^ ]` (clases y negaciones)
6. `|` (alternancia l√≥gica)
7. `( ... )` (agrupamiento)
8. `\1` (retroreferencia)
9. `(?=X)` (lookahead)
10. `(?&lt;=X)` (lookbehind)
11. `(?i)` (modificador: case-insensitive)
12. `\w`, `\b`, `\t` (palabras, l√≠mites, tabulador)
13. **Integraci√≥n final**: ORF completo con codones de inicio y parada

---

# Ejemplo 1: Caracteres literales

Buscar exactamente `ATG`

```regex
ATG
```

‚úÖ Coincide en: `ATGCGTAC`


‚ùì Intenta:  

- Buscar `GCC`
- Ver si coincide `TTT`

---

# Ejemplo 2: Punto `.`

Cualquier letra entre A y G

```regex
A.G
```

‚úÖ Coincide en: `ATG` de `ATGCGTAC`


‚ùì Intenta:

- `G.T` ¬øcoincide?
- `A..T` ¬øfunciona?

---

# Ejemplo 3: Cuantificadores `+`, `*`, `{}`

Los cuantificadores nos dicen **cu√°ntas veces debe repetirse un patr√≥n** para que haya coincidencia.

### üîπ `+` ‚Äî Uno o m√°s.  
Coincide con **al menos una** repetici√≥n del car√°cter o grupo.

- `A+` ‚Üí una o m√°s A seguidas.

**Ejemplos en las secuencias:**

- `A+` ‚Üí coincide en: `AAAAAA` (sec. 5)

---
# Ejemplo 3: Cuantificadores `+`, `*`, `{}`

#### üî∏ `*` ‚Äî Cero o m√°s
Coincide con **cero o m√°s** repeticiones (es decir, incluso si no aparece).

- `T*G` ‚Üí cualquier n√∫mero de T seguidas de una G.

**Ejemplos en las secuencias:**
- `T*G` ‚Üí coincide en: `ATGCGTAC` (sec. 1)

---
# Ejemplo 3: Cuantificadores `+`, `*`, `{}`

#### üîπ `{n}` ‚Äî Exactamente n repeticiones
- `A{3}` ‚Üí exactamente tres A seguidas.

#### üî∏ `{n,}` ‚Äî Al menos n repeticiones
- `G{2,}` ‚Üí dos o m√°s G seguidas.

#### üî∏ `{n,m}` ‚Äî Entre n y m repeticiones
- `C{2,4}` ‚Üí entre dos y cuatro C.

**Ejemplos en las secuencias:**
- `A{3}` ‚Üí coincide en: `AAAAAA` (sec. 5)
- `G{2,}` ‚Üí coincide en: `AATTGGCCAATTGGCC` (sec. 2)

---

# Ejemplo 4: Anclas ^ y $

Solo si est√° al principio.

```regex
^ATG
```

‚úÖ Coincide en: `ATGCGTAC`

‚ùì Intenta:

- Buscar `^GAT`
- Probar `^TGA` en medio

---
# Ejemplo 4: Anclas ^ y $

Solo si est√° **al final** de la secuencia.

```regex
TGA$
```

‚úÖ Coincide en: `ATGCGTACTGA`   
‚ùå No coincide en: `GGCATCTAGGAC`

‚ùì Intenta:

-   Modificar una secuencia que termine en `TAA` o `TAG`.  
-   ¬øQu√© pasa si pones `$` al inicio por error?
    

**Recuerda:**.  
-   `^` significa "empieza con..."
-   `$` significa "termina con..."


---

## Ejemplo 5: Clases `[ ]` y negaciones `[^ ]`

Una **clase de caracteres** permite definir un **conjunto de letras o s√≠mbolos v√°lidos** para una posici√≥n en la secuencia. 

- Los corchetes [ ] indican que **una sola posici√≥n** puede coincidir con **varias opciones**.
- El s√≠mbolo `^` dentro del grupo **niega** (excepto).

Ejemplo: G precedida de A o T.

```regex
[AT]G
```

‚úÖ Coincide en: `ATG` y `TGA`

‚ùì Intenta:   

- `[CT]C`
- `[^AG]T`

---

# Ejemplo 6: Alternancia `|`

Coincide con ATG o GTG.

```regex
ATG|GTG
```

‚úÖ Coincide en: `ATGATGATG`


‚ùì Intenta:  
- `TAG|TAA`
- `CTG|AAC`

---

# Ejemplo 7: Agrupamiento `(...)`

Un **grupo** se define entre par√©ntesis `()` y sirve para:

1. **Agrupar varios caracteres como una sola unidad.**
2. Aplicar **cuantificadores** al grupo completo.
3. Capturar lo que coincide, para usarlo despu√©s (como en retroreferencias).


Por ejemplo: Uno o m√°s repeticiones del grupo.

```regex
(ATG)+
```

‚úÖ Coincide en: `ATGATG`

‚ùì Intenta:   
- `(GC)+`
- `(TA)+`

---

# Ejemplo 8: Retroreferencia `\1`

Una **retroreferencia** te permite **volver a usar un grupo que ya hiciste coincidir antes** en la misma expresi√≥n.

Cuando usas par√©ntesis `( )` en una regex, est√°s **capturando** lo que coincidi√≥.

Luego puedes referirte a ese grupo con:

- `\1` para el **primer grupo**
- `\2` para el segundo, y as√≠ sucesivamente

Ejemplo: Busca repeticiones exactas.

```regex
(GA)\1
```

‚úÖ Coincide en: `GAGAGA`

‚ùì Intenta:    

- `(AT)\1`
- `(CG)\1`

---

# Ejemplo 9: Lookahead `(?=X)`

Un **lookahead** se escribe as√≠: `X(?=Y)`

Significa: **"Encuentra X solo si est√° seguido por Y"**, pero **sin incluir Y** en la coincidencia.

Ejemplo: A que venga antes de T.

```regex
A(?=T)
```

‚úÖ Coincide en: `AGCTTCTGAAGCT`

‚ùì Intenta:

- `G(?=C)`
- `T(?=A)`

---

# Ejemplo 10: Lookbehind `(?&lt;=X)`

Un **lookbehind** se escribe as√≠: `(?&lt;=Y)X`

Significa: **"Encuentra X solo si est√° precedido por Y"**, pero **sin incluir Y** en la coincidencia.


Por ejemplo: A precedido por G.


```regex
(?&lt;=G)A
```

‚úÖ Coincide en: `TGACCTGAAGCTTAGC`

‚ùì Intenta:   
- `(?&lt;=T)C`
- `(?&lt;=C)T`

---

# Modificadores `(?i)`

Los **modificadores** permiten alterar c√≥mo funciona una expresi√≥n regular. Se escriben al inicio con `(?...)`, o se activan con casillas en regex101.

### üîß Modificadores m√°s comunes:

| Modificador | Qu√© hace                      | Ejemplo                   |
|-------------|-------------------------------|---------------------------|
| `(?i)`      | Ignora may√∫sculas/min√∫sculas  | `(?i)atg` ‚Üí ATG o atg     |
| `(?m)`      | Modo multil√≠nea (`^` y `$`)    | `^&gt;` en FASTA multilinea  |
| `(?s)`      | `.` tambi√©n incluye saltos de l√≠nea | √∫til con secuencias largas |
| `(?x)`      | Ignora espacios en la regex y permite comentarios (modo extendido) | para expresiones legibles |

---

**üß† ¬øD√≥nde se usan?**

- (?i) es √∫til cuando no sabes si el texto est√° en may√∫sculas o min√∫sculas.
- (?m) se usa para analizar archivos con varias l√≠neas como .fasta.
- (?s) permite que . incluya saltos de l√≠nea (por defecto no lo hace).


**‚úÖ En regex101:**

Puedes activarlos con las casillas:

- i (insensitive)
- m (multiline)
- s (dotall)

---

# Ejemplo 11: Modificadores `(?i)`

Ignora may√∫sculas/min√∫sculas.

```regex
(?i)atg
```


‚úÖ Coincide en: `atgtaa`, `ATGCGTAC`

‚ùì Intenta:  
- `(?i)taa`
- `atg` sin `(?i)`

---

# Ejemplo 12: Palabras y tabuladores

`ATG` como palabra aislada.

```regex
\bATG\b
```

‚úÖ Coincide en: `gene1    100    ATGCGT`

‚ùì Intenta:    
- `\w{4}`
- `\bTGA\b`

---

# Ejemplo 13: ORF completo

Un marco abierto de lectura completo.

```regex
^ATG[ATGC]{3,}(TAA|TAG|TGA)$
```

‚úÖ Coincide en: `ATGCGTAGCTAA`

‚ùì Intenta:   
- Uno sin cod√≥n de parada

---

# Ejercicios de aplicaci√≥n en biolog√≠a real üß¨

En esta secci√≥n aplicaremos expresiones regulares para identificar motivos biol√≥gicos comunes. Cada ejercicio incluye:

- Una **descripci√≥n del motivo**.
- Una **secuencia ejemplo**.
- Vamos a encontrar una **regex sugerida**.
- Lo que se espera **encontrar en la secuencia** si la expresi√≥n funciona correctamente.


---

# Caja TATA (promotor eucariota)

**¬øQu√© buscamos?**
Una **caja TATA** es una secuencia promotora rica en T y A que marca el inicio de transcripci√≥n en genes eucariotas. Su forma can√≥nica es `TATAAA`, pero puede variar ligeramente.

**Se espera encontrar:** una subcadena como `TATAAA`, `TATATA`, `TATATT`, etc.

```text
ACGTATATAAAGCT
```

Regex:

```regex

```

---

# Codones de inicio

**¬øQu√© buscamos?**
Codones como `ATG`, `GTG` o `TTG`, que pueden servir como **inicio de traducci√≥n** en distintos contextos gen√©ticos.

**Se esperan:** coincidencias exactas con uno de esos tres codones, al inicio de un ORF o dentro de un marco de lectura.

Secuencias ejemplo:

```text
GCCATGCGTACTG
TTGGTCGTGACC
AAGTTGGGCTTGATC
```

Regex:

```regex

```

---

# Codones de parada

**¬øQu√© buscamos?**
Los codones `TAA`, `TAG` y `TGA` indican el **fin de un marco de lectura** (ORF). Suelen encontrarse despu√©s de una regi√≥n codificante.

**Se espera encontrar:** cada vez que uno de estos codones aparece en la secuencia al final de un ORF.

Secuencia ejemplo 1:
```text
ATGCGTACCTAA
GGCATCTAGGAC
AAGGGTGACTGAATC
```

Regex:

```regex

```

---

# Regi√≥n GC rica

**¬øQu√© buscamos?**
Zonas con muchas **guaninas (G)** y **citosinas (C)** juntas, comunes en promotores bacterianos o regiones reguladoras.

**Se espera encontrar:** secuencias como `GGCC`, `GGGCCC`.

Secuencia ejemplo:

```text
GGCCATGGGCCT
```

Regex:
```regex

```

---

# Microsat√©lites (repeticiones CA)

**¬øQu√© buscamos?**
Repeticiones de **CA** como motivo **microsat√©lite**, √∫tiles en estudios poblacionales y gen√≥micos.

**Se espera encontrar:** al menos 5 repeticiones consecutivas de `CA`.


```text
CACACACACACAATG
```

Regex:
```regex

```

---

# Sitio de splicing (intrones eucariotas)

**¬øQu√© buscamos?**
Los intrones eucariotas t√≠picamente inician con `GT` y terminan con `AG`, separados por una secuencia variable.

**Se espera encontrar:** patrones que comiencen con `GT`, tengan entre 3 y 100 nucle√≥tidos, y terminen en `AG`.


```text
GTACGTAGCTAG
```

Regex:
```regex

```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
