<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introducción a la Bioinformática</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introducción a la Bioinformática
]
.institute[
### Licenciatura en Ciencias Genómicas,UNAM
]
.date[
### First version: yyy-mm-dd; Last update: 2023-10-24
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}

.noinverse {
  background-color: #272822;
  color: #d6d6d6;
  text-shadow: 0 0 20px #333;
}

/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}


&lt;/style&gt;


## Objetivo

Lxs alumnxs deberán ser capaces de aplicar filtros con `grep` y conocer las expresiones regulares.
---

## Contenido de la unidad

1. Recordando los comandos básicos de análisis.

2. Ejercicios.

3. Expresiones regulares.


---
## Algunos comandos básicos de análisis

Revisemos los comandos que hemos aprendido:

--

|Comando |   Función básica   |
|----    |---                 |
|`sort`    | Ordena una serie de líneas (o records). |
|`cut`     |Corta porciones seleccionadas de cada línea. |
|`uniq`    |Reporta o filtra las líneas repetidas de un archivo. |
|`wc`      |Reporta la cuenta de líneas, caracteres y bytes. |
|`grep`    |Busca patrones. |
|`man`     |Imprime la descripción y opciones de un comando.  |


---
## Funcionalidades del comando uniq

Algunas funcionalidades del comando `uniq`

--

|Opción |   Comportamiento |
|----    |---                 |
|-d    | Sólo imprime las líneas repetidas. |
|-u    | Sólo imprime las líneas NO repetidas.|
|-i    | Realiza la comparación case-insensitive.|
|-c    | Precede cada línea output con la cuenta del número de veces que esa línea ocurrió.|

---
## Funcionalidades del comando grep

Algunas funcionalidades del comando `grep`

|Opción |   Comportamiento |
|----    |---                 |
|--color | Resalta el texto que corresponde al patrón. |
|-E |Interpreta el patrón como una expresión regular extendida, tipo POSIX.|
|-P |Interpreta el patrón como una expresión regular extendida, tipo Perl.|
|-f |Lee uno o más patrones a partir de un archivo.|
|-i |Ignora mayúsculas/minúsculas.|
|-n |Imprime el número de línea donde se encontró el patrón.|
|-v |Selecciona las líneas en donde no ocurre el patrón.|

---
## Buenas prácticas

Las siguientes recomendaciones te ayudarán a construir flujos de trabajo más robustos y reproducibles:

1. **Piensa en los pasos necesarios** para obtener la respuesta que buscas ANTES de ejecutar tu primer comando.

2. Documenta tus códigos describiendo la funcionalidad de cada sección.

3. Analiza el OUTPUT de CADA PARTE de la TUBERIA para encontrar fallas lógicas o comportamientos inesperados.

4. Recuerda que siempre puedes acceder al manual de un comando o buscar ayuda en internet para entender su funcionamiento.

---
## Ejercicios

Preparando nuestro directorio de trabajo

- Muévete a tu directorio `home` en el servidor.

- Crea la carpeta `practica5`.

- Entra a la carpeta `practica5`.

- Crea la carpeta `data`.

- Copia los archivos ubicados en `/home/compu2/WelcomeBioinfo/datos/practica5` a tu carpeta `data`.

---
## Familiarizándonos con los datos de trabajo

- Visualiza y explora cada uno de los archivos.

- Los archivos llamados `cholerae*` son anotaciónes de la bacteria *Vibrio cholerae*.

- Los archivos llamados `anthracis*` son anotaciónes de la bacteria *Bacillus anthracis*.


---
## Familiarizándonos con los organismos de trabajo

.pull-left[
*Vibrio cholerae*

- Bacteria gram negativa.

- Gamma proteobacteria.

- Produce colera en humanos.

&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Cholera_bacteria_SEM.jpg/440px-Cholera_bacteria_SEM.jpg" width="300px" style="display: block; margin: auto;" /&gt;
]
.pull-right[

*Bacillus anthracis*

- Bacteria gram positiva.

- Es un bacilo formador de endoesporas.

- Es el agente que produce antrax en humanos.


&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/12/Bacillus_anthracis.png/654px-Bacillus_anthracis.png" width="300px" style="display: block; margin: auto;" /&gt;
]

---
## Ejercicio 1: Pregunta

**¿Cuál es la fuente de datos más común para los datos de anotación de
*Vibrio cholerae* y de *Bacillus anthracis*?**

.content-box-blue[
Recuerda: En el caso de *Escherichia coli* todos los datos provenían de
RefSeq, un recurso altamente curado y detallado.
]

--

**¿Cuál es el algoritmo que debemos seguir?**

.content-box-red[ 
Recuerda, la LOGICA de cómo abordar el problema y encontrar la solución es PRIMERO antes de saber que comando vas a usar. 

]
---
## Ejercicio 1: Algoritmo

.content-box-yellow[

Para cada organismo:

- Eliminar el encabezado, porque son comentarios.

- Acceder a la columna 2, ya que es la que nos indica el origen de los datos, la fuente. El resto de datos no nos sirve para abordar la respuesta.

- Ordenar la columna 2 para que todas las fuentes de datos queden juntas.

- Contar cuantas veces se repite cada fuente ( las repeticiones nos indican cuantos features estan anotadas en esa fuente.)

]

---
## Ejercicio 1: Código

Una forma de hacerlo:

```bash
## Fuente de los datos para V. cholerae
grep -v "#" data/cholerae.gff | cut -f2 | \
sort | uniq -c
```

--

```bash
## Fuente de los datos para B. anthracis
grep -v "#" data/anthracis.gff | cut -f2 | \
sort | uniq -c
```

---
## Ejercicio 1: Respuesta


.content-box-green[
*V. cholerae*: Fuentes de datos más comunes:
  - 3771 RefSeq.
  
  - 3609 **Protein Homology**.

*B. anthracis*: Fuentes de datos más comunes:
  - 5530 RefSeq.
  
  - 5332 **Protein Homology**.
]

Para ambos organismos la fuente de casi la mitad de las anotaciónes es la
inferencia de homología para los genes o proteínas.

---
## Ejercicio 2: Pregunta

**¿Cuántos de los genes de *Vibrio cholerae* existen en *Bacillus anthracis*?**

.content-box-blue[

Para fines de este ejercicio, un gene será considerado como el mismo si
tiene el mismo nombre.

]

**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 2: Algoritmo


**¿Cuántos de los genes de *Vibrio cholerae* existen en *Bacillus anthracis*?**

.content-box-yellow[

- Obtener los genes únicos de *V. cholerae*.

- Contar el número de genes únicos de *V. cholerae*.

- Buscar estos genes *B. anthracis*.

- Obtener el nombre de los genes compartidos en *V. cholerae* y *B. anthracis*.

- Obtener el número de genes únicos compartidos.

]

---
## Ejercicio 2: Código

Una forma de hacerlo:

```bash
## Obtener los genes únicos de V. cholerae
grep -v "#" data/cholerae.gff | grep -P "RefSeq\tgene" | cut -f9 | \
cut -d ';' -f2 | sort -u &gt; cholerae_genes.txt

## Contar el número de genes únicos de V. cholerae
wc -l cholerae_genes.txt

## Buscarlos en B. anthracis
grep -w -f cholerae_genes.txt data/anthracis.gff \
&gt; cholerae_anthracis_genes.gff

## Obtener número de genes únicos compartidos
grep -P "RefSeq\tgene" cholerae_anthracis_genes.gff \
| cut -f 9 | cut -d ';' -f2 | sort -u | wc -l

```
---
## Ejercicio 2: Respuesta

.content-box-green[
- *V. cholerae* tiene 3620 genes únicos.

- 506 también existen en *B. anthracis*.
]

---
## Ejercicio 3: Pregunta

**¿Cuántas de las proteínas de *Vibrio cholerae* también existen en *Bacillus anthracis*?**

.content-box-blue[

Para fines de este ejercicio, una proteína será considerada la misma si tiene
la misma descripción en el campo `product`.

]

**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 3: Algoritmo

**¿Cuántas de las proteínas de *Vibrio cholerae* también existen en *Bacillus anthracis*?**

.content-box-yellow[

- Obtener los productos únicos de *V. cholerae*.

- Contar el número de productos únicos de *V. cholerae*.

- Buscar estos productos en *B. anthracis*.

- Obtener el nombre de los productos en *B. anthracis*.

- Obtener el número de productos únicos compartidos.

]

**El campo `product` se encuentra disperso en varias columnas**.


---
## Ejercicio 3: Código

Una forma de hacerlo:

```bash 
## El campo product esta disperso en varias columnas
grep -v "#" data/cholerae.gff | grep -P "\tCDS\t" | cut -f9 | \
cut -d ';' -f7 | grep "product=" &gt; cholerae_products.txt

grep -v "#" data/cholerae.gff | grep -P "\tCDS\t" | cut -f9 | \
cut -d ';' -f8 | grep "product=" &gt;&gt; cholerae_products.txt

grep -v "#" data/cholerae.gff | grep -P "\tCDS\t" | cut -f9 | \
cut -d ';' -f9 | grep "product=" &gt;&gt; cholerae_products.txt

grep -v "#" data/cholerae.gff | grep -P "\tCDS\t" | cut -f9 | \
cut -d ';' -f10 | grep "product=" &gt;&gt; cholerae_products.txt

grep -v "#" data/cholerae.gff | grep -P "\tCDS\t" | cut -f9 | \
cut -d ';' -f11 | grep "product=" &gt;&gt; cholerae_products.txt

## Productos únicos
sort -u cholerae_products.txt &gt; cholerae_products_uniq.txt
wc -l cholerae_products_uniq.txt
```

**Recuerda verificar que tu respuesta sea la correcta**.

---
## Ejercicio 3: Código

La segunda parte de la respuesta:

```bash
## Buscarlos en B. anthracis
grep -wiFf cholerae_products_uniq.txt data/anthracis.gff \
&gt; cholerae_anthracis_products.gff

## Obtener productos compartidos
grep -P "\tCDS\t" cholerae_anthracis_products.gff | cut -f9 | \
cut -d ';' -f7 | grep "product=" &gt; anthracis_shared_products.txt
grep -P "\tCDS\t" cholerae_anthracis_products.gff | cut -f9 | \
cut -d ';' -f8 | grep "product=" &gt;&gt; anthracis_shared_products.txt
grep -P "\tCDS\t" cholerae_anthracis_products.gff | cut -f9 | \
cut -d ';' -f9 | grep "product=" &gt;&gt; anthracis_shared_products.txt
grep -P "\tCDS\t" cholerae_anthracis_products.gff | cut -f9 | \
cut -d ';' -f10 | grep "product=" &gt;&gt; anthracis_shared_products.txt
grep -P "\tCDS\t" cholerae_anthracis_products.gff | cut -f9 | \
cut -d ';' -f11 | grep "product=" &gt;&gt; anthracis_shared_products.txt

## Número de productos únicos
sort -u anthracis_shared_products.txt | wc -l
```

---
## Ejercicio 3: Respuesta

.content-box-green[

- *V. cholerae* tiene 2430 productos proteicos (de acuerdo a la descripción del producto).

- 1024 también existen en *B. anthracis*.
]

---
## Ejercicio 4: Pregunta

**¿Cuál es la longitud aproximada de los genomas de *Vibrio cholerae* y de *Bacillus anthracis*? ¿Cuántos cromosomas tiene cada bacteria?**

.content-box-blue[

**HINT**: Una longitud estimada incluyendo saltos de línea pero sin incluir el
header.

]

**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 4: Algoritmo

**¿Cuál es la longitud aproximada de los genomas de *Vibrio cholerae* y de *Bacillus anthracis*? ¿Cuántos cromosomas tiene cada bacteria?** 

.content-box-yellow[

Para cada organismo:

- Obtener las líneas de encabezado del fasta genómico y contarlas.

- Excluir las líneas de encabezado del fasta genómico y contar los caracteres.

]

---
## Ejercicio 4: Código

Una forma de hacerlo:

```bash
## Numero de cromosomas V. cholerae
grep "&gt;" data/cholerae_genomic.fna

## Longitud aprox de genoma V. cholerae
grep -v "&gt;" data/cholerae_genomic.fna | wc

## Numero de cromosomas B. anthracis
grep "&gt;" data/anthracis_genomic.fna

## Longitud aprox de genoma B. anthracis
grep -v "&gt;" data/anthracis_genomic.fna | wc
```

---
## Ejercicio 4: Respuesta

.content-box-green[

*V. cholerae*:
  - 2 cromosomas.
  - Aprox 4,083,883 pares de bases en su genoma.
  
*B. anthracis*:
  - 1 cromosoma.
  - aprox 5292635 pares de bases en su genoma.
]

---
## Ejercicio 5: Pregunta

**¿Cuál de las siguientes bacterias: *Escherichia coli*, *Vibrio cholerae* y *Bacillus anthracis* tiene:**

- Una proporción mayor de pseudogenes/genes en su genoma.
- Un número mayor de ncRNA anotados.
- Un número mayor de riboswitches anotados?


**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 5: Algoritmo

.content-box-yellow[

Para cada organismo:

- Excluir el encabezado del archivo de anotación.

- Acceder a la columna de feature type.

- Obtener los valores únicos y contar las ocurrencias para cada uno.

]

---
## Ejercicio 5: Código

Una forma de hacerlo:

```bash
## Obtener numero de elementos por feature E. coli
grep -v "#" data/coli.gff | cut -f3 | sort | uniq -c

## Obtener numero de elementos por feature V. cholerae
grep -v "#" data/cholerae.gff | cut -f3 | sort | uniq -c

## Obtener numero de elementos por feature B. anthracis
grep -v "#" data/anthracis.gff | cut -f3 | sort | uniq -c

```
---
## Ejercicio 5: Respuesta

.content-box-green[

Proporción pseudogenes/genes:
  - *E. coli*: 166/4419 = 0.037
  - *V. cholerae*: 80/3657 = 0.21
  - *B. anthracis*: 273/5204 = 0.052 | La proporción más alta pseudogenes/genes.
  
Número de ncRNA anotados:
  - *E. coli*: 72 | El número más alto de ncRNA anotados.
  - *V. cholerae*: 1
  - *B. anthracis*: 2
  
Número de riboswitches anotados:
  - *E. coli*: 0
  - *V. cholerae*: 8
  - *B. anthracis*: 37 | El número más alto de riboswitches.

]
---

## Ejercicio 6: Pregunta

**Genera un archivo en el cual todos los features del mismo tipo se encuentren juntos y ordenados por posición genómica.**

.content-box-blue[

Repite el proceso para *Vibrio cholerae* y *Bacillus anthracis*.

]

**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 6: Algoritmo

**Genera un archivo en el cual todos los features del mismo tipo se encuentren juntos y ordenados por posición genómica.**

.content-box-yellow[

Para cada organismo:

- Ordenar alfabéticamente con base en feature type.

- Ordenar numéricamente por posición de inicio.

]
---
## Ejercicio 6: Código

```bash
## Ordenar por feature_type y posición V. cholerae
sort -k3,3 -k4,4n data/cholerae.gff | less -S

## Ordenar por feature_type y posición B. anthracis
sort -k3,3 -k4,4n data/anthracis.gff | less -S

```

Esto no da el resultamos que esperamos. :(

El archivo de inicio tiene espacios en algunos de los campos lo cual confunde al comando `sort`, debemos indicarle cuál es el separador apropiado.

---
## Ejercicio 6: Código

Otra forma de hacerlo:

```bash
## Debemos indicar que las columnas son separadas por TAB
## Ordenar por feature_type y posición V. cholerae
sort -t$'\t' -k3,3 -k4,4n data/cholerae.gff \
&gt; cholerae_feature_sort.gff

## Ordenar por feature_type y posición B. anthracis
sort -t$'\t' -k3,3 -k4,4n data/anthracis.gff \
&gt; anthracis_feature_sort.gff

```

---
## Ejercicio 6: Respuesta

.content-box-green[

*V. cholerae*:
  - Primer línea: CDS 372 806
  - Última línea: tmRNA 914291 914657
  
*B. anthracis*:
  - Primer línea: CDS 407 1747
  - Última línea: tmRNA 4834383 4834737

]

---
## Ejercicio 7: Pregunta

**¿Para cuántos pseudogenes se tiene anotado el nombre del gene de origen en *Vibrio cholerae* y *Bacillus anthracis*? ¿Cuáles son los genes de origen? ¿Se conoce el gene de origen para todos los pseudogenes?**


**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 7: Algoritmo

**¿Para cuántos pseudogenes se tiene anotado el nombre del gene de origen
Vibrio cholerae y Bacillus anthracis? ¿Cuáles son los genes de origen? ¿Se
conoce el gene de origen para todos los pseudogenes?**

.content-box-yellow[

Para cada organismo:
- Obtener los registros correspondientes a pseudogenes y contarlos.

- Obtener cuantos de esos registros tienen un nombre de gene asociado.

- Obtener los nombres de los genes asociados y contarlos.


]

---
## Ejercicio 7: Código

Una forma de hacerlo, *V. cholerae*:

```bash
## Numero de pseudogenes V. cholerae
grep -P "\tpseudogene\t" data/cholerae.gff | wc -l

## Obtener cuantos tienen un nombre de gene asociado
grep -P "\tpseudogene\t" data/cholerae.gff | grep "gene=" | wc -l

## Nombre de los genes de origen V. cholerae
grep -P "\tpseudogene\t" data/cholerae.gff | grep "gene=" | \
cut -f9 | cut -d';' -f4 | cut -d'=' -f2 | sort -u

## Cuantos son V. cholerae
grep -P "\tpseudogene\t" data/cholerae.gff | grep "gene=" | \
cut -f9 | cut -d';' -f4 | cut -d'=' -f2 | sort -u | wc -l
```
---
## Ejercicio 7: Código

Una forma de hacerlo, *B. anthracis*:

```bash
## Numero de pseudogenes B. anthracis
grep -P "\tpseudogene\t" data/anthracis.gff | wc -l

## Obtener cuantos tienen un nombre de gene asociado
grep -P "\tpseudogene\t" data/anthracis.gff | grep "gene=" | wc -l

## Nombre de los genes de origen B. anthracis
grep -P "\tpseudogene\t" data/anthracis.gff | grep "gene=" | \
cut -f9 | cut -d';' -f4 | cut -d'=' -f2 | sort -u

## Cuantos son B. anthracis
grep -P "\tpseudogene\t" data/anthracis.gff | grep "gene=" | \
cut -f9 | cut -d';' -f4 | cut -d'=' -f2 | sort -u | wc -l
```

---
## Ejercicio 7: Respuesta

.content-box-green[

*V. cholerae*:

- 80 pseudogenes.

  - 13 con gene de origen conocido: dnaG, tsaD, oadA, uvrB, fabB, hldE, pulA, gspD, glgB, gcvP, gcvT, secF, hchA

*B. anthracis*:

- 273 pseudogenes.

  - 20 con gene de origen conocido: abc-f, brnQ, dprA, flhF, fliF, fliM, gntK, hflX, iolE,

]

---
## Ejercicio 8: Pregunta

El archivo FASTA con las secuencias proteicas de un organismo específico (el cual descargaste de NCBI) tiene secuencias que han sido asigndas a distintos niveles taxonómicos. Esta información se encuentra en el header de cada secuencia, entre corchetes, ¿cuáles son los distintos niveles
taxonómicos a los que se han asignado secuencias en los FASTA de *Escherichia coli*, *Vibrio cholerae* y *Bacillus anthracis*?

.content-box-blue[

HINT: El comando `rev` revierte una cadena de texto.

]

**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 8: Algoritmo

**¿Cuáles son los distintos niveles taxonómicos a los que se han asignado secuencias en los FASTA de *Escherichia coli*, *Vibrio cholerae* y *Bacillus anthracis*?**

.content-box-yellow[

- Obtener los identificadores del archivo FASTA.

- Obtener la palabra o palabras entre corchetes.

]
---
## Ejercicio 8: Código

Una forma INCORRECTA de hacerlo: 

```bash
## ESTO NO FUNCIONA
grep "&gt;" data/cholerae_protein.fna | cut -d '[' -f 2 | \
cut -d ']' -f1 | sort -u

grep --color "acetyl-CoA-carboxylase" data/cholerae_protein.fna
```

Existen otros elementos en el identificador que podrían estar entre corchetes. Sin embargo, el nivel taxonómico siempre está en el último. 


---
## Ejercicio 8: Código

Una forma CORRECTA de hacerlo:

```bash
## Niveles taxonómicos proteínas E. coli
grep "&gt;" data/coli_protein.fna | rev | cut -d '[' -f 1 | rev | \
cut -d ']' -f1 | sort -u

## Niveles taxonómicos proteínas V. cholerae
grep "&gt;" data/cholerae_protein.fna | rev | cut -d '[' -f 1 | rev | \
cut -d ']' -f1 | sort -u

## Niveles taxonómicos proteínas B. anthracis
grep "&gt;" data/anthracis_protein.fna | rev | cut -d '[' -f 1 | rev | \
cut -d ']' -f1 | sort -u
```

---
## Ejercicio 8: Respuesta

.pull-left[

- *E.coli*:
  - Escherichia coli str. K-12 substr. MG1655

- *V. cholerae*:
  - Bacteria
  - Gammaproteobacteria
  - Vibrio
  - Vibrio cholerae
  - Vibrionaceae

]

.pull-right[

- *B. anthracis*:
  - Bacillaceae
  - Bacillales
  - Bacilli
  - Bacillus
  - Bacillus anthracis
  - Bacillus cereus group
  - Bacteria
  - Firmicutes
]

.content-box-green[

.tiny[
“ A non-redundant protein record that provides organism information at the level of a genus,
family, or even super-kingdom does not mean that the protein is found in all RefSeq genomes
below that taxonomic classification. It only indicates that the protein is found in more than one
genome of different species for which the genus, family, or super-kingdom classification is the
lowest common taxonomic node.’
]
]
---

## Ejercicio 9: Pregunta

**¿Existe alguna proteína en los archivos FASTA de secuencias proteicas que no se encuentre en el gff de la anotación para *Escherichia coli*, *Vibrio cholerae* y *Bacillus anthracis*?**


**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 9: Algoritmo

**¿Existe alguna proteína en los archivos FASTA de secuencias proteicas que no se encuentre en el gff de la anotación para *Escherichia coli*, *Vibrio cholerae* y *Bacillus anthracis*?**

.content-box-yellow[

- Obtener los ID de las proteína del archivo FASTA y contarlos.

- Obtener los ID del archivo gff de anotación.

- Obtener la intersección de ambas listas.

- Contar los IDs únicos.

]

---
## Ejercicio 9: Código

Para *E.coli*:

```bash
## Obtener los ID de las proteínas E. coli
grep "&gt;" data/coli_protein.fna | cut -d " " -f1 | \
cut -d "&gt;" -f2 | sort -u &gt; coli_protein_id.txt

## Contarlos
wc -l coli_protein_id.txt

## Obtener los ID de la anotación E. coli
cut -f9 data/coli.gff | cut -d ';' -f1 | sort -u &gt; coli_id_fromgff.txt

## Obtener la intersección de ambas listas
grep -Ff coli_protein_id.txt coli_id_fromgff.txt &gt; coli_protein_id.gff

## Contar los IDs únicos
sort -u coli_protein_id.gff | wc -l

```

---
## Ejercicio 9: Código

Para *V. cholerae*:

```bash
## Obtener los ID de las proteínas V. cholerae
grep "&gt;" data/cholerae_protein.fna | cut -d " " -f1 | \
cut -d "&gt;" -f2 | sort -u &gt; cholerae_protein_id.txt

## Contarlos
wc -l cholerae_protein_id.txt

## Obtener los ID de la anotación V. cholerae
cut -f9 data/cholerae.gff | cut -d ';' -f1 | sort -u \
&gt; cholerae_id_fromgff.txt

## Obtener la intersección de ambas listas
grep -Ff cholerae_protein_id.txt cholerae_id_fromgff.txt \
&gt; cholerae_protein_id.gff

## Contar los IDs únicos
cut -d "-" -f2 cholerae_protein_id.gff | sort -u | wc -l
```

---
## Ejercicio 9: Código

Para *B. anthracis*:

```bash
## Obtener los ID de las proteínas B. anthracis
grep "&gt;" data/anthracis_protein.fna | cut -d " " -f1 | \
cut -d "&gt;" -f2 | sort -u &gt; anthracis_protein_id.txt

## Contarlos
wc -l anthracis_protein_id.txt

## Obtener los ID de la anotación B. anthracis
cut -f9 data/anthracis.gff | cut -d ';' -f1 | sort -u \
&gt; anthracis_id_fromgff.txt

## Obtener la intersección de ambas listas
grep -Ff anthracis_protein_id.txt anthracis_id_fromgff.txt \
&gt; anthracis_protein_id.gff

## Contar los IDs únicos
cut -d "-" -f2 anthracis_protein_id.gff | sort -u | wc -l
```

---
## Ejercicio 9: Respuesta

.content-box-green[

*E.coli*:
- 4242 protein id del archivo FASTA de proteínas.
- 4242 protein id en el archivo GFF de anotación.

*V. cholerae*:
- 3492 protein id.
- 3492 protein id en el archivo GFF de anotación.

*B. anthracis*:
- 5071 protein id.
- 5071 protein id en el archivo GFF de anotación.

]

---
## Ejercicio 10: Pregunta

**Genera un archivo FASTA con la secuencia de la proteína FNR de *Vibrio cholerae* y *Bacillus anthracis*. Un archivo por organismo.**



**¿Cuál es el algoritmo que debemos seguir?**

---
## Ejercicio 10: Algoritmo

**Genera un archivo FASTA con la secuencia de la proteína FNR de *Vibrio cholerae* y *Bacillus anthracis*. Un archivo por organismo.**

.content-box-yellow[

- Obtener los IDs del archivo FASTA de proteínas.

- Obtener la posición para la proteína FNR.

- Obtener el siguiente ID.

- Obtener el número de línea del archivo FASTA donde se encuentra el siguiente ID.

- Obtener el número de línea del archivo FASTA donde se encuentra el ID de FNR.

- Extraer el header y la secuencia para FNR.

]

---
## Ejercicio 10: Código

Para *Vibrio cholerae*:

```bash
## Posición del header para la proteína FNR
grep "&gt;" cholerae/cholerae_protein.fna | grep -in fnr

## Obtener el siguiente ID
grep "&gt;" cholerae/cholerae_protein.fna | head -2803 | tail -2

## Número de línea del siguiente ID
grep -n "WP_001177584.1" cholerae/cholerae_protein.fna

## Número de línea del header para FNR
grep -n "WP_001177523.1" cholerae/cholerae_protein.fna

## Extraer el header y la secuencia para FNR
head -15502 cholerae/cholerae_protein.fna | tail -4 &gt; cholerae/FNR.fna
```
---
## Ejercicio 10. Código

Para *Bacillus anthracis*:

```bash
## Posición del header para la proteína FNR
grep "&gt;" cholerae/cholerae_protein.fna | grep -in fnr

## Obtener el siguiente ID
grep "&gt;" anthracis/anthracis_protein.fna | head -2071 | tail -2

## Número de línea del siguiente ID
grep -n "WP_000600649.1" anthracis/anthracis_protein.fna

## Número de línea del header para FNR
grep -n "WP_000600586.1" anthracis/anthracis_protein.fna

## Extraer el header y la secuencia para FNR
head -10042 anthracis/anthracis_protein.fna | tail -4 &gt; anthracis/FNR.fna
```

---
## Ejercicio 10:  Respuesta

.content-box-green[

*V. cholerae*:
  - 4 líneas
  - 304 caracteres
  
*B. anthracis*:
  - 4 líneas
  - 255 caracteres

]

---

---

class: inverse, center, middle

# Expresiones Regulares

---
## ¿Qué es una expresión regular?

Las expresiones regulares son **cadenas de texto** especialmente **codificadas** que se utilizan como **patrones** para hacer ***coincidir** con conjuntos de cadenas. Comenzaron a surgir en la década de 1940 como una forma de describir lenguajes regulares, pero realmente comenzaron a aparecer en el mundo de la programación durante la década de 1970. 

El primer lugar donde pude encontrarlos fue en el editor de texto QED escrito por Ken. Thompson.

Entonces, 

- Una expresión regular es una secuencia de caracteres que definen un patrón de búsqueda.

- Se utilizan para hacer coincidir combinaciones de caracteres en cadenas.

---
## Expresiones Regulares

Las expresiones regulares se convirtieron en una parte importante del conjunto de herramientas que surgió de el sistema operativo Unix: los editores ed, sed y vi (vim), grep, AWK, entre otros, las incluyen.

Las expresiones regulares (regex) se utilizan para identificar, hacer coincidir o administrar el texto.

Sin embargo, Regex es capaz de mucho más que realizar búsquedas de palabras clave. Se puede utilizar para encontrar cualquier tipo de patrón imaginable.

Los patrones se pueden encontrar más fácilmente usando **META CARACTERES** Esos caracteres especiales que hacen que esta herramienta de búsqueda sea mucho más poderosa.

---
## Expresiones Regulares

The grep command offers three regex syntax options:

1. Basic Regular Expression (BRE)

2. **Extended Regular Expressions (ERE)**  ( Option -E)

3. Perl Compatible Regular Expressions (PCRE)  ( Option -P)

By default, grep uses the BRE syntax.

---
## Expresiones Regulares

Esta herramienta puede resultar intimidante tanto para los novatos como para los usuarios más experimentados de Linux.

Desafortunadamente, incluso un patrón relativamente simple como un número de teléfono puede dar como resultado una cadena de expresiones regulares de aspecto aterrador.

Es bueno que sepas, que no existe la necesidad de entrar en pánico cuando veas expresiones como esa.

Una vez que te familiarices con los conceptos básicos de las expresiones regulares, puedes abrir un nuevo mundo de posibilidades para tu día a día.


source: https://ciberninjas.com/linux-que-es-grep/

---
## Expresiones Regulares

Vamos a trabajar primero en unos ejemplos para ver que es una expresión regular usando una herramienta que nos facilitará entender las expresiones regulares 

- https://www.regexpal.com/
- https://regex101.com/

Veamos la interfaz!!

---
## REGEX EJEMPLO DE NUMERO TELEFONICO

* En la interfaz en la sección de TEXT STRING, vamos a poner la información que contendría un archivo, vamos a poner números telefónicos. Primero pongamos este `707-827-7019`

* Podemos poner en la caja de `Regular Expression` el mismo número. Lo que has hecho al colocar el número en la caja de expresión regular es usar algo llamado **literal de cadena**, para que coincida con una cadena en el texto de destino. Un literal de cadena es una representación literal de una cadena.

* En la caja de `Regular Expression` borra el número y deja sólo un número 7. Observa la caja de Test String. El carácter literal (número) 7 en la expresión regular coincide con las cuatro instancias del número 7 en la texto que estás haciendo coincidir.

 - Qué pasa si le quitas el `flag g` ?

---
### REGEX : Match con dígitos usando conjuntos de caracter

Si queremos que la `Regular Expression` identifique a todos los números del String ?

```
[0-9]
```

"Haga coincidir cualquier dígito que encuentre en el rango del 0 al 9".


Los `[]` corchetes no coinciden literalmente porque se tratan especialmente como **metacaracteres**. Un metacarácter tiene un significado especial en expresiones regulares y está **reservado**. Una expresión regular en la forma [0-9] se llama **clase de carácter** o, a veces,
un **conjunto de caracteres**.

Si queremos ciertos digitos específicos, podemos indicarlo

```
[012789]
```


---

### REGEX : Match con dígitos usando conjuntos de caracter

Para hacer coincidir cualquier número de teléfono de 10 dígitos, cuyas partes están separadas por guiones, qué podríamos hacer??

--

```
[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
```

Esto parece demasiado, no? Hay una forma más sencilla de representar este patrón, llamada `shorthand`.

Usando un `Shorthand` de caracteres, `\d` el cual hace match con cualquier digito como lo hace `[0-9]`

```
\d\d\d-\d\d\d-\d\d\d\d
```

El `-` en este caso es un caracter literal.

--

Pero con D `\D`, podemos hacer match con cualquier caracter que no sea un dígito.  Reemplacemos los  `-` por `\D`

```
\d\d\d\D\d\d\d\D\d\d\d\d
```

---

## REGEX : Match con cualquier caracter

También podemos hacer match con el `-` si usamos el punto `.`

```
\d\d\d.\d\d\d.\d\d\d\d
```

El punto actúa esencialmente como un comodín y coincidirá con cualquier carácter (excepto,
en determinadas situaciones, un final de línea).

De hecho, si en lugar de `-` tuvieramos `%` o `=` o cualquier otro caracter nuestra expresión regular tomaría esos casos.

Pega en el Test String, lo ssiguientes casos
 
```
707-827-7017
707-827%7029
707:827:3019
```

¿Qué observas?

---
## REGEX : Captura de grupos y referencias anteriores

Ahora vamos a hacer lo siguiente:

-Vamos a coincidir solo una parte del número de teléfono utilizando lo que se conoce como **grupo de captura**. 
- Luego harás **referencia** al contenido del grupo con una referencia retrospectiva. Para crear un grupo de captura, incluya `\d` entre paréntesis para colocarlo en un grupo.
- y luego siga con un `\1` para hacer referencia a lo que se capturó.

```
(\d)\d\1
```

• (\d) coincide con el primer dígito y lo captura/guarda (el número 7)  
• \d coincide con el siguiente dígito (el número 0) pero no lo captura porque no es
encerrado entre paréntesis  
• \1 hace referencia al dígito capturado (el número 7)  

--

¿Qué hace lo siguiente ?

```
(\d)0\1\D\d\d\1\D\1\d\d\d
```

---
## Usemos grep

1. Copia los archivos de `/home/compu2/WelcomeBioinfo/datos/regex` a tu directorio de practicas.

2. Conjuntos: 

```
# literal
grep "7" phone.txt

# conjunto de caracteres
grep '[0123456789]'  phone.txt

# intervalo de conjuntos
grep "[0-9]" phone.txt
grep '[0-9]'  phone.txt

# un formato de número usando intervalos
grep "[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]" phone.txt
````

---
## Usando grep

3. Haciendo uso de shorthands

```
# podemos usar shorhand
grep "\d" phone.txt      # pero qué pasa??
grep -E "\d" phone.txt   # pero qué pasa??
grep -P "\d" phone.txt   # pero qué pasa??

# los shorthand forman parte de las PCRE
grep -P "\d\d\d-\d\d\d-\d\d\d\d" phone.txt
grep -P "\d\d\d\D\d\d\d\D\d\d\d\d" phone.txt

grep -P "\d\d\d.\d\d\d.\d\d\d\d" phone.txt
```

---
## Usando de grep

Haciendo uso de grupos y referencias

```
grep -P "(\d)\d\1" phone.txt
grep -P "(\d)0\1\D\d\d\1\D\1\d\d\d" phone.txt
```

¿Puedes darme 2 ejemplos más que cumplan con la expresión `(\d)0\1\D\d\d\1\D\1\d\d\d`


https://www.arubanetworks.com/techdocs/ArubaOS_63_Web_Help/Content/ArubaFrameStyles/ESI/Basic_Regular_Expression.htm
https://juncotic.com/grep-y-las-expresiones-regulares-basicas-y-extendidas/

---
## REGEX : Usando cuantificadores

Otra  forma de hacer match con el número telefónico, es la siguiente:

```
\d?
\d+
\d*
\d{3}
\d{3,4}
\d{3}-?\d{3}-?\d{4}
```

- Los **números** entre **llaves** le dicen al procesador de expresiones regulares exactamente **cuántas ocurrencias** de esos dígitos que desea que busque. Las **llaves con números** son una especie de **cuantificador**. Las llaves mismas se consideran **metacaracteres**.

- El signo de interrogación `?` es otro tipo de `cuantificador`. Sigue el guión en el formato normal y significa que el guión es opcional, es decir, que puede haber **cero o una** aparición del guión (uno o ninguno). 

- Existen otros cuantificadores como el el signo más `+`, que significa `uno o más`, o el asterisco `*` que significa `cero o más`.

---
## REGEX : Usando cuantificadores

Usando cuantificadores, nuestra **expresion regular** puede ser más concisa

```
(\d{3,4}[.-]?)+
```

La expresión regular paso a paso:

```
• ( open a capturing group  
• \ start character shorthand (escape the following character)  
• d end character shorthand (match any digit in the range 0 through 9 with \d)  
• { open quantifier  
• 3 minimum quantity to match  
• , separate quantities  
• 4 maximum quantity to match  
• } close quantifier  
• [ open character class  
• . dot or period (matches literal dot)  
• - literal character to match hyphen   
• ] close character class  
• ? zero or one quantifier  
• ) close capturing group  
• + one or more quantifier  
```

---
## REGEX : Usando cuantificadores

El problema de la expresión regular `(\d{3,4}[.-]?)+` si queremos ser estrictos con un número telefónico, es que si aceptamos 4 números al inicio y en medio, ya no sería un número telefónico en el formato que estamos procesando.

Podríamos corregirlo de la siguiente manera:

```
(\d{3}[.-]?){2}\d{4}
```

---
## Usemos grep

Cuantificadores


```
grep  "\d{3}-?\d{3}-?\d{4}" phone.txt # porque no funciona??

grep -P "\d{3}-?\d{3}-?\d{4}" phone.txt
grep -P "(\d{3,4}[.-]?)+" phone.txt
grep -P "(\d{3}[.-]?){2}\d{4}" phone.txt
```

---

## REGEX : Inicio y fin

Las afirmaciones marcan límites, pero no se refieren a sumar caracteres, es decir, no se devolverán caracteres en un resultado. Ellos son también conocidas como afirmaciones de ancho cero. Una afirmación de ancho cero no coincide con un carácter, sino más bien una ubicación en una cadena. Algunos de ellos, como ^ y $, también se denominan **anclas**.

- En tu caja de `Test String` copia lo del archivo `phone.txt`

```
707-827-7019
907-327-3011
707.827.7019
707:827:7019
707-525-7019....
```

y en la Caja de `Regular Expression` seguimos con `(\d{3}[.-]?){2}\d{4}`

Qué observas ? ¿Cuántos estan coloreados y porqué ?

---

## REGEX : Inicio y fin

Que tal si queremos filtrar sólo las líneas que tengan el número telefónico **al inicio** ?

```
^(\d{3}[.-]?){2}\d{4}
```

**^ matches the beginning of a line**

--

Y si quisieramos que solo filtre todas aquellas líneas que solo tengan el número telefónico de inicio a fin de línea.

```
^(\d{3}[.-]?){2}\d{4}$
```

**$ matches the end of a line.**

---

## Resumen

What a regular expression is

• How to use regex, a simple regular expression processor   
--

• How to match string literals   
--

• How to match digits with a character class  
--

• How to match a digit with a character shorthand  
--

• How to match a non-digit with a character shorthand  
--

• How to use a capturing group and a backreference  
--

• How to match an exact quantity of a set of strings  
--

• How to match a character optionally (zero or one) or one or more times  
--

• How to match strings at either the beginning or the end of a line  

---

## Vocabulario básico para formar una expresión regular

|Caracter   | Significado  |
|-----------|--------------------------------|
| .         | Identifica cualquier caracter. |
| ^         | Identifica el inicio de la cadena.|
| $         | Identifica el final de la cadena. |
| *         | Cero o más repticiones. |
| +         | Una o más repeticiones. |
| ?         | Cero o una repetición. |
| {m}       | Exactamente m repeticiones. |
| {m,n}     | Entre m y n repeticiones. |
| pipe      | Identifica la expresión regular antes y después el símbolo. |
| [ ]       | Cualquier caracter dentro de los brackets. |
| \d        | Cualquier caracter numérico. |
| \w        | Cualquier caracter alfanumérico. |

---
## Ejercicio

Genera una expresion regular, que permita extraer todas aquellas líneas donde el `feature` sea gene y vengan las coordenadas del gene

```
     gene            190..255
     gene            337..2799
     gene            2801..3733
     gene            3734..5020
     gene            5234..5530

```

---
# Expresiones regulares: Caracteres

Copia el contenido del archivo `rima.txt` en  [https://regex101.com/](https://regex101.com/) en la caja de TEST STRING.

Veremos algunos metacaracteres y opciones relacionados con strings.

---
## Conjuntos de caracteres

Conjuntos de caracteres e intervalos.

Prueba estas expresiones regulares y observa como hace match

```
# solo vocales
[aeiou]

# caracteres entre la a-z
[a-z]

# caracteres entre a y f
[a-f]

# mayusculas
[A-Z]

# mayusculas y minusculas
[a-zA-Z]
```
---
## Conjuntos de caracteres

También puedes usar shorhands dentro de una clase de caracteres. 

`\w` : Matches any letter, digit or underscore. Equivalent to [a-zA-Z0-9_]
`\s` : Matches any space, tab or newline character.

Probemos
```
\w
\s
````

Por ejemplo, para combinar con el espacio en blanco y caracteres alfabéticos, podrías crear una clase de carácter como esta:

```
# to match white-space and word characters
[\w\s]

# es lo mismo que esto guión y espacio incluidos
[_a-zA-Z \t\n\r]
```

---
## Negar conjuntos y clases de caracteres con *nombre* (POSIX)

Portable Operating System Interface is a family of standards maintained by
IEEE. It includes a regular expression standard, (ISO/IEC/IEEE 9945:2009), which
provides a set of named character classes that have the form

[[:xxxx:]]    where xxxx is a name.

````
# I don’t want these characters.
[^aeiou]

# For alphabetic characters in either upper- or lowercase, use:
[[:alpha:]]

# if you wanted to match non-alphabetic characters
[[:^alpha:]]

# To match space and tab characters
[[:space:]]

# to match all whitespace characters
[[:blank:]]
```
---
# Usemos grep


```
# Probemos estos conjuntos de caracteres, que se marca?
grep --color '[aeiou]' rima.txt 
grep --color '[a-z]' rima.txt 
grep --color '[a-zA-Z]' rima.txt 
grep --color '[a-zA-Z0-9_]' rima.txt 

# shorhands
grep --color '\w' rima.txt 
# shorthand con conjunto, solo con -P
grep --color '[\w\s]' rima.txt 


# usemos una clase con nombre
# buscando solo letras
grep --color '[[:alpha:]]' rima.txt 
```

---

```
# queremos caracteres alfanuméricos
# letras, numeros y _
grep --color '[[:word:]]' rima.txt   # Qué ocurre? ... grep: Invalid character class name

grep -E --color '[[:word:]]' rima.txt # Qué ocurre?

# No todas las clases con nombre estan en Exp basicas o Extendidas
# solo disponibles con -Perl Exp
grep -P --color '[[:word:]]' rima.txt 

# Qué caracteres reconocen estas ?
grep -P --color '[[:punct:]]' rima.txt 
grep -P --color '[[:space:]]' rima.txt 

# Negación con clases con nombre, solo con -P
grep -P --color '[[:^alpha:]]' rima.txt 
```

---
## Límites de palabras y no palabras

Checa que este marcado `insensitive case` en https://regex101.com/

`b` : Marcar el límite de una palabra. Como, ^ o $, \b es una afirmación de ancho cero. Solo limita no hace match con algún caracter.

Observa como no hay un caracter match para  `\b`

```
# buscando literalmente THE
THE

# boundary - perimetro - limite 
# Observa los the al inicio y final de linea, qué caracteres reconoce como limite ?
\bTHE\b

# Para hacer coincidir un límite que no es una palabra
\Be\B

# que pasa con la expresión anterior si unes "from thence" en el texto ?
```

---
## Alternation, Groups, and Backreferences

La alternancia le ofrece la opción de elegir patrones alternativos para combinar.

```
(the|The|THE)
```

Podemos acortar este grupo aplicando una opción. Las opciones le permiten especificar la forma
le gustaría buscar un patrón. En la interfaz puedes activar el `insensitive case` o en grep con la opció -i, pero también puedes indicarlo en la expresión regular usando `(?i)`

```
'(?i)the'
```

**Alternancia y Subpatrones **

```
# Qué selecciona esta expressión
(t|T)h(e|eir)

# y estas ? cuantos match hay ?
(t|T)h(e|eir)+
(t|T)h(e|eir)*

# subpatrones y boundary
\b[tT]h[ceinry]*\b
```

---
## Grupos y referencias

Los grupos guardan en memoria, recuerdo como \1 \2 etc..
Observa los 2 grupos de esta expresión 

```
(It is) (an ancyent Marinere)
```

Si no necesitas aplicar una  backreference en tu expresión regular, no tiene caso guardar en memoria. Podrías escribir un no-captura de grupo con `(?:)`

```
(?:the|The|THE)
```

Que pasó en el resultado con los grupos ?

Y si quiers agregar la opción de insensitive case

```
# los 3 son lo mismo
(?i)(?:the)
(?:(?i)the)
(?i:the)

```
---

## Usemos grep

```
# boundary
grep  '\bTHE\b' rima.txt 

# observa "manner the" porque no  la marca ?
grep '\Be\B' rima.txt
```

Alternativas

```
# todas las opciones de The
grep "(the|The|THE)" rima.txt   # que pasa?

# alternativas solo en extendidas o Perl exp
grep -E "(the|The|THE)" rima.txt

# alternativas y patrones
grep -E "(t|T)h(e|eir)" rima.txt
grep -E "(t|T)h(e|eir)+" rima.txt
grep -E "(t|T)h(e|eir)*" rima.txt

# alternativa con conjuntos, pero solo carcateres independientes
grep -E "\b[tT]h[ceinry]*\b" rima.txt
```
---
## Usemos grep

grep y las opciones -c y -o 
```
grep -Ec "(the|The|THE)" rima.txt
grep -Eo "(the|The|THE)" rima.txt | wc -l 
```
¿Por qué hay diferencia en los totales ? 

Porque -c te da un recuento de coincidencias líneas, pero puede haber más de una coincidencia en cada línea. Si usa -o con wc -l, entonces cada aparición de las diversas formas de la palabra aparecerá en una línea separada y se cuentan.

---
## Usemos grep

```
# busca sin importar mayusculas o minusculas
grep -P  '(?i)the' rima.txt 

# lo mismo - insensitive case con opción de grep -i
grep -P -i  'the' rima.txt 

# sin guardar el grupo
grep -P  '(?i:the)' rima.txt 

grep -P  '(?i:the)\1' rima.txt  # que pasa

```

---

## Ejercicio

1. ¿Cómo definirías una o más expresiones regulares que describan a todas las siguientes líneas?

```
YP_588464.1
YP_588465.1
YP_588466.1
YP_588467.1
YP_588468.1
YP_588469.1
YP_588470.1
```

---
## Ejercicio

Genera una expresión regular que permita extraer todos los gene con sus coordenadas genómicas. Deben tomarse en cuenta genes en forward o en la cadena complementaria. Usa el archivo `NC_000913.3.gbk `

```
     gene            337..2799
     gene            5234..5530
     gene            complement(5683..6459)
     gene            complement(6529..7959)
     gene            8238..9191
```

---
## Ejercicio

2. ¿Cómo definirías una o más expresiones regulares que describan a todas las siguientes líneas?

Sitios de unión del Factor de Transcripción LexA (File: LexA_tfbs.txt)

```
TACTGTTTTTATATACAGTATA
TACTGTTTATTTATACAGTAAA
TACTGTTTTTATATACAGTAGT
AACTGGTTTTATATACAGTAAA
AACTGTTTTTTTATCCAGTATA
AACTGTGATTTTATACAGTATA
TACTGGTTATTTATACAGGTAA
AACTGTATTTATATACAGTTGT
CCCTGGGTGTATATACAGTTAT
TGCTGTGAGTATATACAGCAAA
TGCTGGTTATCTATCCAGTGTA
AGCTGTTTATTTATACAGTGAG
TACTGTTATTGTGTACAGTATA 
```

Checa si tu expresión regular, puede encontrar todos los sitios.

---
## Ejercicios

3. Hacer una o más expresiones regulares que permitan hacer match con los renglones donde el feature es gene y traigan nombre de gene (Name=)

```
NC_000913.3     RefSeq  gene    190     255     .       +       .      
ID=gene-b0001;Dbxref=ASAP:ABE-0000006,ECOCYC:EG11277,EcoGene:EG11277,GeneID:944742;Name=thrL;gbkey=Gene;gene=thrL;gene_biotype=protein_coding;gene_synonym=ECK0001;locus_tag=b0001
NC_000913.3     RefSeq  gene    337     2799    .       +       .      
ID=gene-b0002;Dbxref=ASAP:ABE-0000008,ECOCYC:EG10998,EcoGene:EG10998,GeneID:945803;Name=thrA;gbkey=Gene;gene=thrA;gene_biotype=protein_coding;gene_synonym=ECK0002,Hs,thrA1,thrA2,thrD;locus_tag=b0002
```

&lt;br&gt;

4. Extender la anterior expresión regular, para que además el mismo nombre del gene este en la etiqueta de gene=

---

## Ejercicios

Las enzimas de restricción cortan en base a patrones; por ejemplo, la enzima aPEK1 corta moléculas de ADN como "GCAGC" o "GCTGC". Con base en los patrones reconocidos, algunas enzimas son “cortadoras frecuentes” y otras no; los cortadores más frecuentes muestran más ubicaciones en un genoma pero sacrifican la profundidad de secuenciación. Por esta razón, los investigadores suelen querer conocer, dado un patrón enzimático y una secuencia genómica, la distribución de las longitudes de los fragmentos que resultarán.

Escribe un programa o comando que tome una secuencia de ADN y un patrón de expresión regular y muestre todos los match encontrados para aPEK1. Como ejemplo, “AAAAGCAGCAAAAAAAAGCTGCAAGCAGCAAAAA" cuando se procesa para aPEK1 deben obtenerse las secuencias y la posición donde se se hace el corte ( checa las opciones de -ob de grep)

---

&lt;!--
```
# hat is, grep knows where the ends of the lines are, but sees the input as one big line. 
# -o print only matching. 
grep -zo "^THE.*\?$"  rime_marinere.txt 

^THE.*
```

grep -P --color "\tgene\t.+gene=[^;]{3,10};" coli.gff

Expresion para seleccionar el ombre del organismo
grep -o -P "\[[^\]]+\]" anthracis_protein.fna
--&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(logos/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
