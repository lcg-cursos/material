<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Python II y GitHub</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Python II y GitHub
### Licenciatura en Ciencias Genómicas, UNAM
### First version: 2021-08-03; Last update: 2023-08-08

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;



## Contenido

1. [Especificar versiones en Git con tag](1-Etiquetas.html)  

2. [Trabajar con ramas en Git: git branch](./leccion2/2-Ramas.html)  

3. [Manejo de issues en GitHub](./leccion3/3-issues.html)  

4. [Gestión de un proyecto con GitHub](./leccion4/4-project.html)  


---
# Versionamiento en Git usando tags

## Objetivo
Al finalizar la lección, podremos identificar estados importantes de nuestro código, así como las liberaciones del mismo, mediante el uso de etiquetas en Git/GitHub.



&lt;img src="img/git-tags.png" width="250px" style="display: block; margin: auto;" /&gt;

---

## Introducción

Imaginemos que trabajamos en un proyecto de software para nuestra clase. A lo largo del desarrollo hemos invertido mucho tiempo en la solución de problemas, lo que implica agregar nuevas funcionalidades e incluso modificar o corregir el código que ya hemos hecho (commits). 
&lt;img src="img/workFlow.png" width="550px" style="display: block; margin: auto;" /&gt;

Sin embargo, durante todo ese proceso, a veces quisieramos guardar una "foto" del **estado actual** de nuestro código, por considerarlo funcionable. Estas "fotos" las podemos llamar **versiones estables** de nuestro código. ¿y qué podemos hacer con ellas?:

- Obtener resultados de versiones pasadas
- Ejecutar programas anteriores
- Rastreo de programas por fecha, commits.

---

#  tags : Etiquetando estados de código

.full-width[.content-box-blue[Los tags son una manera de etiquetar **estados** de tu repositorio, que se usa comúnmente para indicar las **versiones** o releases de un proyecto mantenido con Git.]]

.pull-left[

&lt;img src="img/tagsSchema.png" width="650px" style="display: block; margin: auto;" /&gt;


]

.pull-right[

- **Estados** importantes en la vida de un repositorio

- Usado principalmente para el manejo de los **releases** de un proyecto

- Permite mantener informados a los usuarios del código del software y otros desarrolladores de las **versiones** de una aplicación

]


---

## Git Tag 

El etiquetado es una herramienta fundamental para que el mismo programador, los usuarios, así como otros sistemas sepan cuándo el software ha cambiado y se permitan desencadenar procesos a ejecutar cada vez que esto ocurre.

.full-width[.content-box-red[Esta operación se conoce comúnmente con el nombre de **"tagging"**]]

Comando para crear etiquetas  

Sintaxis:

```
git tag
```


---
## Numeración de las versiones

- Git es un sistema de control de versiones

--

- Permite mantener todos los estados por los que ha pasado cualquiera de sus archivos

--

- Con **git tag** no nos referimos a la versión de un archivo en particular, sino de __todo__ el proyecto de manera global

--

- **git tag** permite hacer referencia a un estado del **repositorio completo**, práctica que suele ocurrir cada vez que se libera una nueva versión del software

&lt;img src="img/tagging.png" width="500px" style="display: block; margin: auto;" /&gt;

---
## Numeración de las versiones

Las versiones de los proyectos las define el equipo de desarrollo, y se recomienda no crearlas de manera arbitraria, sino darles un significado real de acuerdo a las _modificaciones realizadas en el proyecto de software_.

&lt;img src="img/versions.png" width="250px" style="display: block; margin: auto;" /&gt;

Ejemplo: https://github.com/google/material-design-icons/tags
---
## Numeración de las versiones

- Generalmente los cambios se pueden dividir en tres niveles de **"importancia": mayor, menor y pequeño ajuste** -&gt; versión **x**,**y**,**z**.

&lt;img src="img/desc-versiones.png" width="350px" style="display: block; margin: auto;" /&gt;

--

- x -&gt; si los cambios son tan grandes que cambian la forma en la que funcionaba tu software haciendo que ya no haya compatibilidad con la versión anterior

--

- y -&gt; si agregas una nueva funcionalidad que es compatible con tus versiones anteriores

--

- z -&gt; si lo que hiciste fue arreglar un bug  

---
## Crear un tag en Git

Hasta este momento hemos trabajado con un repositorio en Git, realizando cambios y enviandolos al servidor remoto, sin embargo, no tenemos ninguna numeración de versión y ningún tag que nos indique si el código ya se encuentra estable o si existe una nueva versión. 

Supongamos que empezamos por el número de versión **0.1.0**. Entonces para crear la correspondiente etiqueta usaremos el comando: 

Sintaxis:  

.full-width[.content-box-yellow[git tag [tag_name]]] 


Ejemplo:

.full-width[.content-box-yellow[git tag v0.1.0]]


Con esto estaremos etiquetando el estado actual del repositorio, el cual apunta al _último commit realizado_.

---
## Crear un tag en Git

Para poder definir una nueva etiqueta, será necesario realizar cambios al repositorio y confirmarlos mediante un commit.  

Para crear una segunda etiqueta:

.full-width[.content-box-yellow[git tag v0.2.0]]


---
## Consultar los estados de versiones en el repositorio con _git tag_

Una vez creado un tag en el repositorio, podremos ejecutar el comando "git tag", el cual nos informará sobre las versiones que hemos etiquetado hasta el momento.

Sintaxis:  

.full-width[.content-box-yellow[git tag]]

Resultado:  

.full-width[.content-box-yellow[$ git tag &lt;br&gt;
v0.1.0&lt;br&gt;
v0.2.0
]]


---
## Crear tags con mensaje

Crear etiquetas en Git es genial, pero necesitaremos agregar una descripción a la etiqueta que permita a los colaboradores (y a nosotros mismos) entender porqué fue creada.
Por ejemplo: no creamos un commit sin un mensaje, así que una etiqueta no debe crearse sin un mensaje.

.full-width[.content-box-yellow[git tag v0.0.3 -m "Tercera versión, cambios menores"]]


Consultar las etiquetas hasta el momento.

Resultado:

.full-width[.content-box-yellow[$ git tag &lt;br&gt;
v0.0.1&lt;br&gt;
v0.0.2&lt;br&gt;
v0.0.3  Se agregó logo de la LCG
]]

---
## Consultar una etiqueta en particular con _git show_

Otro comando interesante en el manejo de etiquetas es  **git show** _[tag_name]_. Este te permite conocer cómo estaba el repositorio en cada estado que has etiquetado, es decir, en cada versión.

.full-width[.content-box-yellow[git show v0.0.2]]

Resultado:

&lt;img src="img/show.png" width="450px" style="display: block; margin: auto;" /&gt;

---
## Desafio

Hemos trabajado mucho en nuestro repositorio de git llamado _python_class_ y ahora que tenemos una versión estable que queremos liberar necesitamos crear una etiqueta para identificarla. Para ello, realizamos los siguientes pasos:

1. Ir a una terminal 
--

2. Localizar tu repositorio Git de trabajo
--

3. Abrir el archivo "sequence.txt" ubicado en el directorio src/, modificarlo
.full-width[.content-box-yellow[git add sequence.txt]]
--

4. Crear una etiqueta
.full-width[.content-box-yellow[git tag v0.1.0]]
--

5. Revisar la etiqueta creada en el repositorio
.full-width[.content-box-yellow[git tag]]
--

**¿Este flujo de acciones será correcto?**



---
## Consideraciones


- Antes de modificar cualquier archivo revisa el estado de tu repositorio  
**git status**

--

- Si tienes cambios pendientes debes confirmarlos  
**git add**  
**git commit**  

--

- Recuerda agregar un mensaje cuando crees la etiqueta  
**git tag [tag_name] -m "[mensaje]"**

--

- Si quieres revisar una etiqueta en particular puedes definirlo  
**git show [tag_name]**

---
## Práctica
1. Abre una terminal y localiza tu repositorio de trabajo
--

2. Revisa el estado de tu repositorio. Asegurate que no haya nada pendiente por confirmar
.full-width[.content-box-yellow[git status]]
--

3. Abre el archivo "sequence.txt", modificalo y confirma los cambios
.full-width[.content-box-yellow[git add sequence.txt]]
.full-width[.content-box-yellow[git commit -m "Modificando el archivo sequence.txt"]]
--

4. Crea una etiqueta
.full-width[.content-box-yellow[git tag v0.1.0 -m "Archivo sequence completo y actualizado"]]
--

5. Revisa la etiqueta creada en el repositorio
.full-width[.content-box-yellow[git show v0.1.0]]


---


## Enviar etiquetas y hacer push de los commits al mismo tiempo

Hasta el momento todas las etiquetas que hemos creado han sido en nuestro repositorio local. Sin embargo, llevar estos cambios y las etiquetas al repositorio remoto es muy importante para que los usuarios de nuestros programas conozcan que existe una liberación de código.

Para ello, será necesario hacer un push a GitHub para enviar los cambios, así como _todas_ las etiquetas al mismo tiempo, utilizando el siguiente comando:

Sintaxis:  

.full-width[.content-box-yellow[git push origin master --tags]]


---



## Práctica

1-Envía los últimos cambios realizados en el repositorio local, así como la etiqueta recien creada al repositorio remoto

.full-width[.content-box-yellow[git push origin master --tags]]

2-Ve a GitHub y asegurate que los cambios realizados (commit) y la etiqueta se encuentren en el repositorio

---

## Enviar a GitHub una etiqueta en particular

Imaginemos que hacemos varias modificaciones (commits) al archivo "reverse-complement.py" y generamos distintas etiquetas para nuestro control interno. Sin embargo, cuando tenemos una versión estable deseamos llevar solo una de ellas al servidor remoto. Para ello usaremos el siguiente comando:

Sintaxis:  

.full-width[.content-box-yellow[git push origin master [tag_name]]]


Ejemplo:  

.full-width[.content-box-yellow[git push origin master v0.1.0]]


---


## Desafio

Jennifer ha realizado algunos cambios a sus scripts de Python y ha generado 3 tags (v0.1.0, v0.1.1 y v1.0.0) en su repositorio local para identificar aspectos relevantes de dichas modificaciones. 

¿Cuál de los siguientes comandos le permitiría a Jennifer enviar la etiqueta v1.0.0 y los últimos cambios al repositorio remoto en GitHub para compartirlo con sus compañeros?


.full-width[.content-box-yellow[a) git push origin master v1.0.0]]
.full-width[.content-box-yellow[b) git push origin]]
.full-width[.content-box-yellow[c) git push origin master --tags]]
.full-width[.content-box-yellow[d) git --tags master v1.0.0 ]]



---

## Desafio


La opción correcta es la "a", ya que indica exactamente la etiqueta a enviar, así como los cambios realizados. 

La opción "b", c" y "d" son incorrectas en sintaxis.

---


## Práctica

1-Localiza el archivo "AT-percentage.py" y modifica la sección _AUTHOR_

--

2-Confirma los cambios:  
__git add__,  __git commit -m__

--

3-Crea una etiqueta con mensaje:  
__git tag [tag_name] -m "mensaje"__

--

4-Repite los pasos 1-3, modificando las sessiones _CATEGORY_ y crea la etiqueta v0.2.0  

--

5-Revisar las etiquetas creadas:  
__git tag__ o __git show [tag_name]__

--

6-Envía a GitHub solo una de las etiquetas creadas, así como su commit correspondiente:  
__git push origin master [tag_name]__


---

## Eliminar una etiqueta local

Ahora que nos encontramos realizando etiquetas en nuestro repositorio, puede ser que comentamos algún error al momento de crearlas o simplemente queremos borrarlas. En caso de que se requiera eliminar una etiqueta, podemos hacer uso del comando:

.full-width[.content-box-yellow[git tag -d [tag_name]]]

--

 Ejemplo:

.full-width[.content-box-yellow[git tag -d v0.0.5]]

__Importante:__ La opción __-d__ es utilizada para borrar la etiqueta.

---
## Práctica


1-Realiza cambios en el archivo sequence.txt

--

2-Confirma los cambios:  
__git add__,  __git commit -m__

--

3-Crea una etiqueta con mensaje:  
__git tag [tag_name] -m "mensaje"__

--

4-Revisar las etiquetas creadas:  
__git tag__ o __git show [tag_name]__

--

5-Borra la etiqueta recíen creada:  
__git tag -d [tag_name]__

--


6-Verifica que la etiqueta haya sido eliminada localmente:  
__git tag__ o __git show [tag_name]__

---


## Eliminar una etiqueta remota

Hay que tomar en cuenta que en el paso anterior la etiqueta fue eliminada del repositorio local. Si la etiqueta se encontrara ya en el repositorio remoto (GitHub), para eliminarla debemos usar el siguiente comando:

.full-width[.content-box-yellow[git push --delete origin [tag_name]]]

--

 Ejemplo:

.full-width[.content-box-yellow[git push --delete origin v0.0.2]]


---

## Práctica


1-Revisa las etiquetas que actualmente se encuentran en tu repositorio remoto (GitHub):  
__Sección "tags"__

--

2-Identifica la etiqueta que deseas borrar y usa el comando:  
__git push --delete origin [tag_name]__

--

3-Revisar las etiquetas del repositorio remoto (GitHub):  
__Sección "tags"__

---

## Etiquetas desde GitHub

No solo desde Git podemos crear etiquetas, también desde nuestro repositorio remoto en GitHub tenemos la opción de generar etiquetas que indiquen las liberaciones del código.

En la página principal del repositorio, se encuentra la opción __releases__, donde se puede acceder a la información sobre las versiones etiquetadas en el proyecto, así como etiquetar nuevas versiones.


&lt;img src="img/github-tags.png" width="550px" style="display: block; margin: auto;" /&gt;

&lt;img src="img/new-tag.png" width="350px" style="display: block; margin: auto;" /&gt;

---

## Conclusión

Hemos aprendido a etiquetar estados de un proyecto con Git, algo que se realiza comúnmente para informar en el sistema de control de versiones de los **releases** principales durante la vida del software. Para trabajar las etiquetas en Git necesitamos conocer al menos los siguientes comandos:

.full-width[.content-box-yellow[git tag [tag_name] - m [mensaje]]]
.full-width[.content-box-yellow[git show [tag_name]]]
.full-width[.content-box-yellow[git tag -d [tag_name]]]


Puedes obtener más ayuda sobre opciones para el comando git tag con:  
__git tag -h__



---

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(img/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
