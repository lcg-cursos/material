<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introducci√≥n al Desarrollo de Software Cient√≠fico</title>
    <meta charset="utf-8" />
    <meta name="author" content="Heladia Salgado" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Introducci√≥n al Desarrollo de Software Cient√≠fico
]
.author[
### Heladia Salgado
]
.institute[
### Licenciatura en Ciencias Gen√≥micas,UNAM
]
.date[
### First version: yyy-mm-dd; Last update: 2026-02-05
]

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;



# Prop√≥sito de la sesi√≥n

-   Introducir una **visi√≥n general** del desarrollo de software cient√≠fico
    
-   Comprender que desarrollar software **no es solo escribir c√≥digo**
    
-   Conocer el **lenguaje b√°sico** y la forma de trabajo del curso
    
-   Alinear expectativas sobre **qu√© se har√° y c√≥mo se evaluar√°**
    
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;

&gt; Esta sesi√≥n no busca dominio t√©cnico,    
&gt; sino **entender el panorama completo** del curso.


---

## Contenido de la sesi√≥n

1. Prop√≥sito del curso y alineaci√≥n de expectativas  
2. ¬øQu√© es desarrollar software?  
3. Software en ciencias gen√≥micas  
4. Ciclo de vida del desarrollo de software  
5. Requisitos y contexto  
6. An√°lisis y dise√±o  
7. Codificaci√≥n y buenas pr√°cticas  
8. Pruebas  
9. Liberaci√≥n (Release)  
10. Mantenimiento y evoluci√≥n  
11. Modelado b√°sico de sistemas  
12. Infraestructura y herramientas  
13. Actividad guiada y cierre


---
# Alinear expectativas del curso

-   **Programar** no es lo mismo que **desarrollar software**
    
-   Escribir c√≥digo es solo **una parte** del proceso
    
-   En el curso trabajaremos con:
    
    -   organizaci√≥n,  
    -   documentaci√≥n,  
    -   pruebas,  
    -   y uso responsable de IA
        
-   El objetivo es producir software **comprensible, reproducible y validable**
    

.content-box-gray[
&gt; En este curso, _que el c√≥digo ‚Äúfuncione‚Äù no es suficiente_.
]

---
# ¬øQu√© es el desarrollo de software?

-   Es un **proceso estructurado** para resolver un problema
    
-   No comienza escribiendo c√≥digo
    
-   Incluye:
    
    -   comprender el problema,
        
    -   dise√±ar una soluci√≥n,
        
    -   implementarla,
        
    -   verificar que funciona,
        
    -   mantenerla en el tiempo
        


.content-box-gray[
&gt; El desarrollo de software es un **proceso**, no una acci√≥n aislada.
&gt; El c√≥digo es **un resultado**, no el punto de partida.

]

---

## Programar vs desarrollar software

| Programar | Desarrollar software |
|----------|----------------------|
| Escribir c√≥digo | Dise√±ar una soluci√≥n |
| Resolver una tarea puntual | Resolver un problema completo |
| Enfocado en la implementaci√≥n | Enfocado en el proceso |
| Puede no documentarse | Requiere documentaci√≥n |
| Dif√≠cil de reproducir | Reproducible y verificable |


&lt;br&gt;
&lt;br&gt;


.content-box-gray[
&gt; En este curso **no solo programamos**,  
&gt; **desarrollamos software cient√≠fico**.
]


---
## El papel del software en ciencias gen√≥micas

En las ciencias gen√≥micas, el software se utiliza para:

-   Analizar **grandes vol√∫menes de datos**
    
-   Automatizar an√°lisis complejos y repetitivos
    
-   Garantizar la **reproducibilidad** de los resultados
    
-   Documentar de forma clara los procedimientos computacionales
    
-   Compartir an√°lisis con otros investigadores
    
&lt;br&gt;

.content-box-gray[
&gt; En gen√≥mica, el software **no es accesorio**:  
&gt; es parte integral del m√©todo cient√≠fico.

&gt; Si no puedes repetir el an√°lisis, el resultado no es confiable
]
---

## Tipos de software cient√≠fico

En la pr√°ctica cient√≠fica encontramos distintos tipos de software:

-   **Scripts**  
    Programas peque√±os para tareas espec√≠ficas o exploratorias.
    
-   **Pipelines de an√°lisis**  
    Conjunto de pasos encadenados para procesar datos de forma sistem√°tica.
    
-   **Notebooks computacionales**  
    Mezclan c√≥digo, resultados y explicaci√≥n (exploraci√≥n y docencia).
    
-   **Herramientas especializadas**  
    Software m√°s complejo y reutilizable para an√°lisis espec√≠ficos.
    

&gt; El curso trabajar√° principalmente con **scripts y proyectos peque√±os**, aplicando principios que escalan a herramientas m√°s grandes.

&gt; No todos los problemas requieren el mismo tipo de software.

---
## Ciclo de vida del desarrollo de software

El desarrollo de software se organiza en **etapas** que permiten pasar:

-   de una **idea inicial**
    
-   a una **soluci√≥n funcional**,
    
-   mantenible y reproducible en el tiempo.
    

Estas etapas forman el **ciclo de vida del desarrollo de software**.

&lt;br&gt;


.content-box-gray[
&gt; Cada etapa genera productos  
&gt; y aporta criterios de calidad.
] 

---
## Fases del ciclo de vida

De forma general, el ciclo incluye:

-   üí° **Planificaci√≥n** ‚Üí idea / foco
    
-   üìã **Requisitos** ‚Üí checklist / documento
    
-   üß© **An√°lisis y dise√±o** ‚Üí diagrama / nodos
    
-   üíª **Codificaci√≥n** ‚Üí c√≥digo / Python
    
-   üîç **Pruebas** ‚Üí lupa / check
    
-   üöÄ **Liberaci√≥n (Release)** ‚Üí paquete / etiqueta
    
-   üîß **Mantenimiento** ‚Üí engrane
    


.content-box-gray[
&gt; No todas las fases tienen la misma duraci√≥n,  
&gt; pero **todas son necesarias**.
] 

---

&lt;img src="img/software_ia.png" width="900px" style="display: block; margin: auto;" /&gt;

---
## El ciclo como proceso iterativo

### El desarrollo no es lineal

Aunque se presenta como una secuencia, el desarrollo de software es **iterativo**:

-   Se regresa a requisitos cuando aparecen nuevas necesidades
    
-   El dise√±o se ajusta al encontrar problemas
    
-   El c√≥digo se refina despu√©s de probar
    
-   El mantenimiento puede generar nuevos ciclos
    

&gt; Desarrollar software es un proceso  
&gt; de **mejora continua**, no una l√≠nea recta.

---
## üìã La fase de requisitos

La fase de **requisitos** define:

-   **qu√© debe hacer el software**
    
-   **bajo qu√© condiciones debe hacerlo**
    

Es el punto donde se traduce una idea general  
en una **descripci√≥n concreta del problema**.

&lt;br&gt;
&lt;br&gt;

.content-box-gray[
&gt; Sin requisitos claros,  
&gt; no hay forma de saber si el software es correcto.
]


---
### Requisitos funcionales

Los **requisitos funcionales** describen:

-   las **acciones** que el software debe realizar
    
-   el **comportamiento esperado** del sistema
    

&lt;br&gt;

Responden a la pregunta:

&gt; **¬øQu√© hace el software?**

&lt;br&gt;

Ejemplos:

-   El sistema debe filtrar genes con baja expresi√≥n.  
-   El sistema debe normalizar los datos de entrada. 
-   El sistema debe calcular la expresi√≥n diferencial entre dos condiciones.
-   El sistema debe generar archivos de salida en formato CSV.   

---
### Requisitos no funcionales

Los **requisitos no funcionales** describen:

-   **c√≥mo debe comportarse** el software
-   restricciones y cualidades del sistema

Ejemplos:

- Rendimiento:  
   - El sistema debe procesar un archivo de **hasta 10 GB en menos de 5 minutos**.  
   - El tiempo de respuesta para una consulta no debe exceder 2 segundos.  
- Usabilidad:    
   - El software debe poder ejecutarse desde la l√≠nea de comandos **con una sola instrucci√≥n**.  
   - El sistema debe proporcionar mensajes de **error claros y comprensibles**.
- Portabilidad:
   - El programa debe funcionar **en Linux, macOS y Windows**.
- El c√≥digo debe seguir las convenciones PEP8.

---
### üß† Din√°mica. Proyecto: `suma_numeros`

**Lista de requisitos**

1.  El sistema debe solicitar dos n√∫meros al usuario.
    
2.  El sistema debe calcular la suma de los n√∫meros ingresados.
    
3.  El sistema debe mostrar el resultado en pantalla.
    
4.  El sistema debe ejecutarse desde la l√≠nea de comandos.
    
5.  El sistema debe manejar entradas no num√©ricas sin fallar.
    
6.  El sistema debe responder en menos de un segundo.
    
7.  El c√≥digo debe ser f√°cil de entender y modificar.
    
8.  El programa debe funcionar en Linux, macOS y Windows.
    
9.  El sistema debe incluir un archivo `README.md` con instrucciones de uso.


&gt; ¬øCu√°les describen _qu√© hace_ el sistema  
&gt; y cu√°les describen _c√≥mo debe comportarse_?

---

## Documento de contexto

Durante la fase de requisitos se genera un **documento de contexto**, que puede ser:

-   `README.md`.  
-   un documento Markdown.  
-   una secci√≥n inicial de un notebook
    

Este documento describe:

-   el problema. 
-   los requisitos funcionales. 
-   los requisitos no funcionales. 
-   los supuestos y limitaciones
    
&lt;br&gt;

.content-box-gray[
&gt; El documento de contexto gu√≠a  
&gt; todo el desarrollo posterior.
]

---
## Requisitos como contexto para la IA

Cuando se utiliza inteligencia artificial para apoyar el desarrollo:

-   los **requisitos** son el **contexto del problema**. 
-   definen lo que la IA debe entender.  
-   reducen ambig√ºedades e interpretaciones incorrectas
    
.content-box-red[
&gt; Una IA sin contexto claro  
&gt; **infiere o inventa** la soluci√≥n.
] 

Definir bien los requisitos mejora:

-   la calidad del c√≥digo generado. 
-   la coherencia de las respuestas. 
-   la validaci√≥n posterior mediante pruebas

&lt;br&gt;
&gt; La IA no piensa: responde al contexto que le damos

---
## An√°lisis y dise√±o

Despu√©s de definir los requisitos, el siguiente paso es   **pensar la soluci√≥n antes de programar**.

-   Los requisitos definen **el problema**
    
-   El an√°lisis y el dise√±o definen **la soluci√≥n**
    
&lt;br&gt;
&lt;br&gt;

.content-box-gray[
&gt; Programar sin an√°lisis y dise√±o  
&gt; suele generar c√≥digo fr√°gil y dif√≠cil de mantener.

&gt; Esta es la parte que m√°s se salta‚Ä¶ y la que m√°s problemas evita
]

---

## An√°lisis: entender el problema

El **an√°lisis** consiste en:

-   descomponer el problema en partes m√°s peque√±as
    
-   identificar:
    
    -   entradas,
        
    -   procesos,
        
    -   salidas
        
-   detectar ambig√ºedades y casos especiales
    
&lt;br&gt;

.content-box-gray[
&gt; Analizar es **entender bien el problema**  
&gt; antes de pensar en c√≥digo.
]

---

### üß† Din√°mica. An√°lisis : `suma_numeros`

-   ¬øQu√© datos entran al sistema?  
-   ¬øQu√© datos salen?  
-   ¬øQu√© casos pueden fallar?  
-   ¬øQu√© suposiciones estamos haciendo?  
-   ¬øQu√© no vamos a resolver en este proyecto?

--

Respuesta:

-   **Entradas:** dos valores num√©ricos.
-   **Salidas:** un n√∫mero (la suma).
-   **Casos l√≠mite:** entradas no num√©ricas, valores vac√≠os, n√∫meros grandes.
-   **Suposiciones:** solo dos n√∫meros, suma simple.
-   **Fuera de alcance:** interfaz gr√°fica, m√∫ltiples operaciones.
    
üëâ Aqu√≠ todav√≠a **no hay funciones ni m√≥dulos**.

---

## Dise√±o: estructurar la soluci√≥n

El **dise√±o** consiste en:

-   organizar los pasos del an√°lisis
    
-   definir el flujo de trabajo
    
-   decidir:
    
    -   funciones,
        
    -   m√≥dulos,
        
    -   scripts
        
-   establecer convenciones b√°sicas
    
&lt;br&gt;

.content-box-gray[
&gt; Dise√±ar es decidir **c√≥mo se implementar√°**  
&gt; la soluci√≥n antes de escribir c√≥digo.
]

---
### üß† Din√°mica. Dise√±o : `suma_numeros`

**Preguntas gu√≠a:**

-   ¬øQu√© componentes o funciones necesitamos?  
-   ¬øC√≥mo se comunican entre s√≠?  
-   ¬øQu√© decisiones de estructura tomamos?  
-   ¬øD√≥nde se manejar√°n los errores?  
-   ¬øQu√© requisitos influyen en el dise√±o?

--

Respuesta:

-   Funci√≥n para leer entradas.
-   Funci√≥n para validar n√∫meros.
-   Funci√≥n para realizar la suma.
-   Funci√≥n principal (`main`).
-   Separaci√≥n entre l√≥gica y entrada/salida.

---

## An√°lisis y dise√±o como contexto

### Contexto del problema y de la soluci√≥n

En este curso, el **contexto completo** se entiende como:

-   **Contexto del problema**
    
    -   requisitos funcionales
        
    -   requisitos no funcionales
        
-   **Contexto de la soluci√≥n**
    
    -   an√°lisis
        
    -   dise√±o
        
.content-box-gray[
&gt; Ambos contextos son necesarios  
&gt; para desarrollar software y usar IA de forma efectiva.


&gt; Sin dise√±o, la IA inventa; con dise√±o, la IA colabora
]
---

## Qu√© se espera en este curso

### An√°lisis y dise√±o en este curso

En este curso **no se espera**:

-   documentaci√≥n extensa
    
-   diagramas formales complejos
    

S√≠ se espera que el estudiante:

-   explique el flujo general del an√°lisis
    
-   justifique decisiones importantes
    
-   use esquemas simples o texto estructurado
    
-   piense antes de programar
    

&gt; El objetivo no es documentar m√°s,  
&gt; sino **pensar mejor**.

---
## üíª  Codificaci√≥n

La **codificaci√≥n** consiste en implementar el dise√±o en forma de c√≥digo.

En este curso se utilizar√°:

-   **Visual Studio Code (VSC)** como entorno de desarrollo
    
-   Extensiones b√°sicas para edici√≥n y ejecuci√≥n
    
-   **Inteligencia artificial** como apoyo al desarrollo
    
&lt;br&gt;

.content-box-gray[
&gt; El c√≥digo se escribe  
&gt; a partir del **contexto definido previamente**.
]

---
## IA como asistente, no sustituto

### Uso de IA durante la codificaci√≥n

En este curso, la IA se utiliza como:

-   apoyo para explorar soluciones.  
-   ayuda para escribir o refinar c√≥digo. 
-   herramienta para aprender y comprender
    

La IA **no sustituye**:

-   el razonamiento del estudiante. 
-   la responsabilidad sobre el c√≥digo.  
-   la validaci√≥n de resultados
    
&lt;br&gt;

.content-box-red[
&gt; El estudiante es responsable  
&gt; del c√≥digo que entrega.

]

---
## Orden en software cient√≠fico

### ¬øPor qu√© importa el orden?

En software cient√≠fico, el orden no es est√©tico:

-   permite entender qu√© hace el software
    
-   facilita la reproducibilidad
    
-   ayuda a detectar errores
    
-   permite que otros reutilicen el trabajo
    
&lt;br&gt;

**¬øC√≥mo conseguimos ese orden?**

.content-box-gray[
&gt; C√≥digo desordenado  
&gt; produce resultados poco confiables.
]

---
## Est√°ndares b√°sicos del curso

En el curso se trabajar√° con est√°ndares pr√°cticos:

-   **Markdown** para documentaci√≥n (`README.md`)
    
-   **PEP8** para estilo de c√≥digo en Python
    
-   **pytest** para pruebas automatizadas
    
-   Convenciones claras de nombres
    
&lt;br&gt;

&gt; Los est√°ndares permiten  
&gt; que el software sea entendible y compartible.


---
## Buenas pr√°cticas al codificar

Durante la codificaci√≥n se espera:

-   mantenga una **estructura clara del proyecto**

-   separe **c√≥digo, datos y documentaci√≥n**
    
-   escriba c√≥digo **legible y modular**
    
-   documentaci√≥n interna m√≠nima
    
-   definici√≥n de casos de prueba
    
&lt;br&gt;
&lt;br&gt;

&gt; C√≥digo que funciona pero no se entiende  
&gt; **no es buen software cient√≠fico**.

---
## Convenciones de nombres

Se recomienda seguir **PEP8**:

-   **snake_case** para:
    
    -   variables
        
    -   funciones
        
    -   archivos  
        _Ejemplo:_ `sumar_numeros`
        
-   **PascalCase** para:
    
    -   clases  
        _Ejemplo:_ `AnalizadorDatos`
        
&lt;br&gt;

&gt; Nombrar bien facilita leer, entender y mantener el c√≥digo.


---
## üîç La fase de pruebas

La etapa de **pruebas** tiene como objetivo verificar que:

-   el software **cumple con los requisitos definidos**.  
-   el comportamiento es el esperado.  
-   los errores se detectan de forma temprana. 
    
    
En el curso se trabajar√° con:

-   **Casos normales**.  
    -   situaciones esperadas de uso
-   **Casos l√≠mite**.  
    -   condiciones extremas o poco comunes
        

.content-box-gray[
&gt; Probar no es desconfiar del c√≥digo,  
&gt; es **validar cient√≠ficamente** su comportamiento.
]

---
## Casos de prueba

### ¬øDe d√≥nde salen los casos de prueba?

-   **Requisitos**  
    Definen _qu√© debe cumplirse_.  
    ‚Üí Aqu√≠ nace la **intenci√≥n de probar**.
    
-   **An√°lisis**  
    Identifica _situaciones relevantes_.  
    ‚Üí Entradas v√°lidas, inv√°lidas y casos l√≠mite.
    
-   **Dise√±o**  
    Decide _c√≥mo ser√° posible probar_.  
    ‚Üí Separaci√≥n de l√≥gica, manejo de errores, funciones testeables.
    
-   **Pruebas**  
    Formalizan y verifican.  
    ‚Üí Casos de prueba expl√≠citos con entradas y salidas esperadas.
    

üëâ Aqu√≠ ya aparece la **estructura**, pero a√∫n no el c√≥digo.

---
## üß† Din√°mica. Pruebas :`suma_numeros`

**¬øQu√© deber√≠amos probar?**

--

| Caso | Entrada | ¬øQu√© esperamos? |
|-----|--------|------------------|
| 1 | `2`, `3` | Muestra `5` |
| 2 | `-1`, `4` | Muestra `3` |
| 3 | `0`, `0` | Muestra `0` |
| 4 | `a`, `3` | Mensaje de error |
| 5 | *(vac√≠o)*, `5` | Mensaje de error |


- ¬øQu√© requisito verifica cada caso?
- ¬øCu√°les prueban funcionalidad?
- ¬øCu√°les prueban manejo de errores?
- ¬øQu√© caso falta?

&gt; **Idea clave:**  
&gt; Probar es verificar requisitos usando ejemplos concretos.

---

## Pruebas automatizadas

### Pruebas automatizadas con pytest

Adem√°s de documentar casos de prueba, se utilizar√°:

-   **pytest** para pruebas automatizadas. 
-   ejecuci√≥n sistem√°tica y repetible.  
-   detecci√≥n r√°pida de errores al modificar c√≥digo
    

pytest se usa para:

-   formalizar los casos de prueba.  
-   validar cambios, incluidos los generados con IA.  
-   mantener confianza en el software
    
&lt;br&gt;

.content-box-blue[
&gt; La IA puede proponer c√≥digo;  
&gt; **las pruebas deciden si es correcto**.
]

---
## ¬øQu√© significa liberar software?

La **liberaci√≥n** es la etapa en la que el software se prepara para que:

-   otras personas puedan **descargarlo**
    
-   puedan **instalarlo**
    
-   puedan **usarlo**
    
-   **sin depender del autor**
    
&lt;br&gt;

.content-box-gray[
&gt; Subir c√≥digo a GitHub no es lo mismo que liberar software.

&gt; Liberar software es hacerlo **reproducible y utilizable por terceros**.
]

---
## Elementos m√≠nimos de una liberaci√≥n

### ¬øCu√°ndo un software est√° correctamente liberado?

Un proyecto liberado debe incluir, al menos:

-   **C√≥digo organizado**
    
-   **Documentaci√≥n de uso**
    
-   **Licencia clara**
    

Si falta alguno de estos elementos:

.content-box-red[
&gt; el software **no es reproducible**  
&gt; o **no es reutilizable**.
]

---
## Documento `RELEASE.md`

En este curso, la liberaci√≥n incluye un documento espec√≠fico:

üìÑ **`RELEASE.md`**

Este documento debe contener:

-   descripci√≥n breve del software.  
-   requisitos (lenguaje, versi√≥n, dependencias). 
-   instrucciones para descargar el proyecto.  
-   pasos de instalaci√≥n. 
-   ejemplo m√≠nimo de uso. 
-   referencia a la licencia
    

.content-box-gray[
&gt; `RELEASE.md` permite que cualquier usuario  
&gt; **repita el uso del software sin ayuda del autor**.
]

---
## Licencia de uso del software

Todo software p√∫blico debe incluir una **licencia** que indique:

-   qu√© se puede hacer con el c√≥digo
    
-   qu√© no se permite
    
-   bajo qu√© condiciones se puede reutilizar
    

La licencia debe incluirse en un archivo:

üìÑ **`LICENSE`**

&gt; Sin licencia expl√≠cita,  
&gt; el c√≥digo **no es legalmente reutilizable**.

---
## Mantenimiento del software

Despu√©s de la liberaci√≥n, el software entra en una etapa de **mantenimiento**, donde se:

-   corrigen errores detectados
    
-   ajusta el software a nuevas necesidades
    
-   mejora la claridad o el rendimiento
    
-   adapta el c√≥digo a nuevos entornos o datos
    
&lt;b&gt;

&gt; El desarrollo de software  
&gt; **no termina con la liberaci√≥n**.

---
## Evoluci√≥n e iteraci√≥n

### El software como proceso evolutivo

En la pr√°ctica, el desarrollo de software es:

-   **iterativo**, no lineal
    
-   un proceso de mejora continua
    
-   sensible a nuevos requisitos y descubrimientos
    

Cambios en:

-   el problema cient√≠fico
    
-   los datos
    
-   las herramientas  
    pueden requerir volver a etapas anteriores.
    

&gt; Volver atr√°s no es fallar,  
&gt; es **mejorar el software**.

---

class: inverse, center, middle

# 

---
## Infraestructura de trabajo del curso

Para desarrollar software de forma ordenada se requiere una infraestructura m√≠nima:

-   un **entorno de desarrollo** configurado
    
-   un **editor de c√≥digo**
    
-   una **estructura clara de proyecto**
    
-   uso b√°sico de la **l√≠nea de comandos**
    

&gt; La infraestructura no es un obst√°culo,  
&gt; es lo que permite trabajar de forma reproducible.

---
## Herramientas principales

Durante el curso se trabajar√° con:

-   **Visual Studio Code (VSC)**  
    Editor de c√≥digo principal.
    
-   **L√≠nea de comandos**  
    Para ejecutar programas y pruebas.
    
-   **Gesti√≥n de entornos y dependencias**  
    Para asegurar reproducibilidad.
    

---
## Actividad Exploratoria

1. Verificar la instalaci√≥n del entorno. Siguiendo la gu√≠a de instalaci√≥n.

2. Crear proyecto `hola`

3. Explorar Visual Studio Code

4. Abrir proyecto `hola`. 
  - Crear un programa `main.py` que imprima "Hola! que tal!".
  - Correr el programa
  
5. Explorar el proyecto suma_numeros


---

### Entregable / Evidencia (formativa)

En la p√°gina del curso, subir:

-   **Dos capturas de pantalla de Visual Studio Code**:
    
    1.  Proyecto `hola`, mostrando:
        
        -   El archivo `main.py`
            
        -   La terminal con el mensaje impreso correctamente.
            
    2.  Proyecto `suma_numeros`, mostrando:
        
        -   El proyecto abierto en VSC
            
        -   La ejecuci√≥n del programa en la terminal.

---

### Cierre de la sesi√≥n

Para finalizar la sesi√≥n:

-   reflexionaremos sobre:
    
    -   qu√© implica desarrollar software
        
    -   c√≥mo se trabajar√° durante el curso
        
-   resolveremos dudas iniciales
    
-   conectaremos esta sesi√≥n con las siguientes
    

&gt; Este material servir√° como **referencia base**  
&gt; para el resto del curso.



---

class: inverse, center, middle

# 

---


## ¬øPor qu√© modelar antes de programar?

### Modelado b√°sico de sistemas

Antes de escribir c√≥digo, es √∫til **representar el sistema** de forma gr√°fica o conceptual.

El modelado ayuda a:

-   clarificar ideas
    
-   entender el flujo del an√°lisis
    
-   comunicar la soluci√≥n a otros
    
-   detectar problemas tempranamente
    

&gt; Modelar no es burocracia,  
&gt; es **pensar con claridad**.

---
## Tipos de diagramas simples

En el curso se usar√°n diagramas **simples**, como:

-   **Diagramas de flujo**
    
    -   representan pasos y decisiones
        
-   **Casos de uso**
    
    -   describen qu√© puede hacer el sistema y qui√©n lo usa
        
-   **Diagramas de componentes (ligeros)**
    
    -   muestran partes principales del sistema
        
&lt;br&gt;

.content-box-gray[
&gt; Los diagramas buscan **entender**,  
&gt; no documentar formalmente.
]
---

## Diagramas en Markdown

### Diagramas con Mermaid

En este curso se usar√°n herramientas ligeras como:

-   **Mermaid**
    
-   **PlantUML**
    

Ventajas:

-   se integran en documentos Markdown
    
-   permiten versionar diagramas junto con el c√≥digo
    
-   no requieren herramientas externas complejas
    
&lt;br&gt;

.content-box-gray[
&gt; El diagrama es parte del **contexto del proyecto**.

]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(img/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
